<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[RunLoop 学习笔记]]></title>
      <url>/2018/07/12/RunLoop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><p>顾名思义，运行循环，在程序运行过程中循环做一些事情。</p>
<p><strong>应用范畴</strong></p>
<ul>
<li>定时器（Timer）、PerformSelector</li>
<li>GCD Async Main Queue</li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li>AutoreleasePool</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">// 开启Runloop循环，程序并不会马上退出，而是保持运行状态</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>RunLoop的基本作用</strong></p>
<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li>
<li>……</li>
</ul>
<h2 id="RunLoop对象"><a href="#RunLoop对象" class="headerlink" title="RunLoop对象"></a>RunLoop对象</h2><p>有2套API来访问和使用RunLoop</p>
<ul>
<li>Foundation：NSRunLoop</li>
<li>Core Foundation：CFRunLoopRef</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Foundation</span></div><div class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获得当前线程的RunLoop对象</span></div><div class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获得主线程的RunLoop对象</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Core Foundation</span></div><div class="line">CFRunLoopGetCurrent(); <span class="comment">// 获得当前线程的RunLoop对象</span></div><div class="line">CFRunLoopGetMain(); <span class="comment">// 获得主线程的RunLoop对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象，NSRunLoop是基于CFRunLoopRef的一层OC包装CFRunLoopRef是<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">开源的</a></p>
</blockquote>
<h2 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h2><p>每条线程都有唯一的一个与之对应的RunLoop对象，RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 伪代码</span></div><div class="line">runloops[thread] = runloop</div></pre></td></tr></table></figure>
<p>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建，在线程结束时销毁。</p>
<p>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop。</p>
<h2 id="RunLoop相关的类"><a href="#RunLoop相关的类" class="headerlink" title="RunLoop相关的类"></a>RunLoop相关的类</h2><p>Core Foundation中关于RunLoop的5个类</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RunLoop 结构体</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">CF_BRIDGED_MUTABLE_TYPE</span><span class="params">(id)</span> __CFRunLoop * CFRunLoopRef</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></div><div class="line">    <span class="keyword">pthread_t</span> _pthread;</div><div class="line">    CFMutableSetRef _commonModes;</div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RunLoopMode 结构体</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></div><div class="line">    CFStringRef _name;</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由结构体可见，<code>CFRunLoopRef</code>中<code>_modes</code>成员变量中存着多个<code>CFRunLoopModeRef</code>，<code>CFRunLoopMode</code>存着<code>CFRunLoopSourceRef</code>、<code>CFRunLoopTimerRef</code>、<code>CFRunLoopObserverRef</code>。</p>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fszwrklod6j20sg0lcqj8.jpg" alt=""></p>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><p>CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer。</p>
<p>RunLoop启动时只能选择其中一个Mode，作为currentMode，如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入。</p>
<p>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响，如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出。</p>
<p><strong>常见的2种Mode</strong></p>
<ul>
<li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
</ul>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p><code>_observers</code> 是用来监听 <code>RunLoop</code> 事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Run Loop Observer Activities */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),			<span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),	 <span class="comment">// 即将处理Timer</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),	 <span class="comment">// 即将处理Source</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),	 <span class="comment">// 即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),	 <span class="comment">// 刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),			<span class="comment">// 即将退出Loop</span></div><div class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以通过添加<code>Observer</code>来监听<code>Runloop</code>事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 Observer</span></div><div class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, <span class="number">0</span>, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">        <span class="comment">// 监听各类 RunLoop 事件</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 添加 Observer 到 RunLoop 中</span></div><div class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class="line"><span class="comment">// 释放</span></div><div class="line">CFRelease(observer);</div></pre></td></tr></table></figure>
<h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><p><strong>Source0</strong></p>
<ul>
<li>触摸事件处理</li>
<li>performSelector:onThread:</li>
</ul>
<p><strong>Source1</strong></p>
<ul>
<li>基于Port的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><p><strong>Timers</strong></p>
<ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
<h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><ul>
<li><p>01、通知Observers：进入Loop</p>
</li>
<li><p>02、通知Observers：即将处理Timers</p>
</li>
<li><p>03、通知Observers：即将处理Sources</p>
</li>
<li><p>04、处理Blocks</p>
</li>
<li><p>05、处理Source0（可能会再次处理Blocks）</p>
</li>
<li><p>06、如果存在Source1，就跳转到第8步</p>
</li>
<li><p>07、通知Observers：开始休眠（等待消息唤醒）</p>
</li>
<li><p>08、通知Observers：结束休眠（被某个消息唤醒）</p>
</li>
<li><ul>
<li>01&gt; 处理Timer</li>
<li>02&gt; 处理GCD Async To Main Queue</li>
<li>03&gt; 处理Source1</li>
</ul>
</li>
<li><p>09、处理Blocks</p>
</li>
<li><p>10、根据前面的执行结果，决定如何操作</p>
</li>
<li><ul>
<li>01&gt; 回到第02步</li>
<li>02&gt; 退出Loop</li>
</ul>
</li>
<li><p>11、通知Observers：退出Loop</p>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1ft6scmiy5dj21er0ocdn2.jpg" alt=""></p>
<h2 id="RunLoop的应用"><a href="#RunLoop的应用" class="headerlink" title="RunLoop的应用"></a>RunLoop的应用</h2><h3 id="解决NSTimer在滑动时停止工作的问题"><a href="#解决NSTimer在滑动时停止工作的问题" class="headerlink" title="解决NSTimer在滑动时停止工作的问题"></a>解决NSTimer在滑动时停止工作的问题</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:<span class="literal">nil</span>];</div><div class="line"><span class="comment">// NSDefaultRunLoopMode、UITrackingRunLoopMode才是真正存在的模式</span></div><div class="line"><span class="comment">// NSRunLoopCommonModes并不是一个真的模式，它只是一个标记</span></div><div class="line"><span class="comment">// timer能在_commonModes数组中存放的模式下工作</span></div><div class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure>
<h3 id="控制线程生命周期（线程保活）"><a href="#控制线程生命周期（线程保活）" class="headerlink" title="控制线程生命周期（线程保活）"></a>控制线程生命周期（线程保活）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJPermenantThreadTask)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPermenantThread</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/** 开启线程 */</span></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"><span class="comment">/** 在当前子线程执行一个任务 */</span></div><div class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task;</div><div class="line"><span class="comment">/** 结束线程 */</span></div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** MJThread **/</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJThread</span> : <span class="title">NSThread</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJThread</span></span></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">/** MJPermenantThread **/</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPermenantThread</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) MJThread *innerThread;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isStopped) <span class="built_in">BOOL</span> stopped;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPermenantThread</span></span></div><div class="line"><span class="meta">#pragma mark - public methods</span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.stopped = <span class="literal">NO</span>;</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">        <span class="comment">// 初始化线程</span></div><div class="line">        <span class="keyword">self</span>.innerThread = [[MJThread alloc] initWithBlock:^&#123;</div><div class="line">            <span class="comment">// 第一次获取时就会创建 RunLoop 对象</span></div><div class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">            <span class="comment">// 判断是否需要继续循环</span></div><div class="line">            <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</div><div class="line">                <span class="comment">// Runloop 运行模式</span></div><div class="line">                [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        <span class="comment">// 启动线程</span></div><div class="line">        [<span class="keyword">self</span>.innerThread start];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</div><div class="line">    [<span class="keyword">self</span>.innerThread start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 在子线程执行任务</span></div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 在子线程退出 Runloop 循环</span></div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">    <span class="comment">// 对象销毁前退出 Runloop</span></div><div class="line">    [<span class="keyword">self</span> stop];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - private methods</span></div><div class="line">- (<span class="keyword">void</span>)__stop &#123;</div><div class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</div><div class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</div><div class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将block执行封装在方法中</span></div><div class="line">- (<span class="keyword">void</span>)__executeTask:(MJPermenantThreadTask)task &#123;</div><div class="line">    task();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="监控应用卡顿"><a href="#监控应用卡顿" class="headerlink" title="监控应用卡顿"></a>监控应用卡顿</h3><p>待续</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>待续</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC Runtime 学习笔记]]></title>
      <url>/2018/07/05/OC-Runtime-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h2><p>在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址。</p>
<p>从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</div><div class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    <span class="keyword">uintptr_t</span> bits;</div><div class="line"></div><div class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></div><div class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</div><div class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</div><div class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></div><div class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>nonpointer</strong></p>
<p>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址；</p>
<p>1，代表优化过，使用位域存储更多的信息。</p>
<p><strong>has_assoc</strong></p>
<p>是否有设置过关联对象，如果没有，释放时会更快。</p>
<p><strong>has_cxx_dtor</strong></p>
<p>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快。</p>
<p><strong>shiftcls</strong></p>
<p>存储着Class、Meta-Class对象的内存地址信息。</p>
<p><strong>magic</strong></p>
<p>用于在调试时分辨对象是否未完成初始化。</p>
<p><strong>weakly_referenced</strong></p>
<p>是否有被弱引用指向过，如果没有，释放时会更快。</p>
<p><strong>deallocating</strong></p>
<p>对象是否正在释放。</p>
<p><strong>extra_rc</strong></p>
<p>里面存储的值是引用计数器减1。</p>
<p><strong>has_sidetable_rc</strong></p>
<p>引用计数器是否过大无法存储在isa中，如果为1，那么引用计数会存储在一个叫SideTable的类的属性中。</p>
<h2 id="Class-结构体"><a href="#Class-结构体" class="headerlink" title="Class 结构体"></a>Class 结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</div><div class="line">    <span class="comment">// Class ISA;</span></div><div class="line">    Class superclass;</div><div class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable （方法缓存）</span></div><div class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags（用于获取具体类信息）</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bits &amp; FAST_DATA_MASK 得到 class_rw_t 结构体实例</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span> <span class="comment">// rw 代表 readwrite</span></div><div class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></div><div class="line">    <span class="keyword">uint32_t</span> flags;</div><div class="line">    <span class="keyword">uint32_t</span> version;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</div><div class="line">    <span class="keyword">method_array_t</span> methods;      <span class="comment">// 方法列表</span></div><div class="line">    <span class="keyword">property_array_t</span> properties; <span class="comment">// 属性列表</span></div><div class="line">    <span class="keyword">protocol_array_t</span> protocols;  <span class="comment">// 协议列表</span></div><div class="line">    Class firstSubclass;</div><div class="line">    Class nextSiblingClass;</div><div class="line">    <span class="keyword">char</span> *demangledName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<p>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</p>
<p>method_array_t 方法列表数据结构如下表格，数组中嵌套method_list_t数组，method_list_t数组中存着method_t，因此可以动态添加方法，我们还可以猜测一个分类中的方法相当于一个method_list_t数组。</p>
<table>
<thead>
<tr>
<th style="text-align:center">method_list_t</th>
<th style="text-align:center">method_list_t</th>
<th style="text-align:center">method_list_t</th>
<th style="text-align:center">…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">method_t</td>
<td style="text-align:center">method_t</td>
<td style="text-align:center">method_t</td>
<td style="text-align:center">method_t</td>
</tr>
<tr>
<td style="text-align:center">method_t</td>
<td style="text-align:center">method_t</td>
<td style="text-align:center">method_t</td>
<td style="text-align:center">method_t</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class_ro_t 存着类的原始信息</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span> <span class="comment">// ro 代表 readonly</span></div><div class="line">    <span class="keyword">uint32_t</span> flags;</div><div class="line">    <span class="keyword">uint32_t</span> instanceStart;</div><div class="line">    <span class="keyword">uint32_t</span> instanceSize;   <span class="comment">// instance 对象占用的内存空间</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">uint32_t</span> reserved;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;       <span class="comment">// 类名</span></div><div class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</div><div class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;  <span class="comment">// 成员变量列表</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</div><div class="line">    <span class="keyword">property_list_t</span> *baseProperties;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<p>method_list_t 数据结构如下表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">method_t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">method_t</td>
</tr>
<tr>
<td style="text-align:center">method_t</td>
</tr>
<tr>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></div><div class="line">    SEL name;	<span class="comment">// 方法名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;  <span class="comment">// 编码（返回值类型，参数类型）</span></div><div class="line">    IMP imp;    <span class="comment">// 指向函数的指针（函数地址）</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<p><strong>IMP代表函数的具体实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></div><div class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</div></pre></td></tr></table></figure>
<p><strong>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似</strong></p>
<ul>
<li>可以通过@selector()和sel_registerName()获得</li>
</ul>
<ul>
<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a method selector.</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></div></pre></td></tr></table></figure>
<p><strong>types</strong></p>
<p>包含了函数返回值、参数编码的字符串</p>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>	<span class="comment">// 散列表</span></div><div class="line">    <span class="keyword">mask_t</span> _mask;			   <span class="comment">// 散列表的长度 - 1</span></div><div class="line">    <span class="keyword">mask_t</span> _occupied;           <span class="comment">// 已缓存的方法数量</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></div><div class="line">    <span class="keyword">cache_key_t</span> _key;</div><div class="line">    IMP _imp;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<p><strong>缓存查找</strong></p>
<ul>
<li>objc-cache.mm</li>
<li>bucket_t * cache_t::find(cache_key_t k, id receiver)</li>
</ul>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *object = [<span class="built_in">NSObject</span> alloc];</div><div class="line">object = [object init];</div><div class="line"><span class="comment">// objc_msgSend(object, sel_registerName("init"));</span></div><div class="line"><span class="comment">// 消息接收者（receiver）：object</span></div><div class="line"><span class="comment">// 消息名称：init</span></div><div class="line">        </div><div class="line">[<span class="built_in">NSObject</span> initialize];</div><div class="line"><span class="comment">// objc_msgSend(objc_getClass("NSObject"), sel_registerName("initialize"));</span></div><div class="line"><span class="comment">// 消息接收者（receiver）：[NSObject class]</span></div><div class="line"><span class="comment">// 消息名称：initialize</span></div><div class="line"></div><div class="line"><span class="comment">// sel_registerName("init") = @selector(init);</span></div><div class="line"><span class="comment">// objc_getClass("NSObject") = [NSObject class];</span></div></pre></td></tr></table></figure>
<p>OC的方法调用：消息机制，给方法调用者发送消息。所以OC中的方法调用，其实都是转换为objc_msgSend函数的调用。</p>
<p>objc_msgSend的执行流程可以分为3大阶段</p>
<ul>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ul>
<p>如果三个阶段都没找不到合适的方法进行调用，会报错 <code>unrecognized selector sent to instance</code>。</p>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fsonly3w1mj20sg0lcwvz.jpg" alt=""></p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p><strong>消息发送</strong>流程走完后没有找到对应方法的实现，就会进入<strong>动态方法解析</strong>流程。</p>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fspj1gcc3oj20sg0lch16.jpg" alt=""></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 添加实例方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test1)) &#123;</div><div class="line">        Method method = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(instanceResolve));</div><div class="line">        class_addMethod(<span class="keyword">self</span>, sel, method_getImplementation(method), method_getTypeEncoding(method));</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加类方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test2)) &#123;</div><div class="line">        Method method = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(instanceResolve));</div><div class="line">        <span class="comment">// 注意这里第一个参数传的是元类对象</span></div><div class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, method_getImplementation(method), method_getTypeEncoding(method));</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fspqxeri6wj20sg0lcdvu.jpg" alt=""></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</div><div class="line">        <span class="comment">// objc_msgSend([[NSObject alloc] init], aSelector)</span></div><div class="line">        <span class="keyword">return</span> [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法签名：返回值类型、参数类型</span></div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v16@0:8"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></div><div class="line"><span class="comment">// anInvocation.target 方法调用者</span></div><div class="line"><span class="comment">// anInvocation.selector 方法名</span></div><div class="line"><span class="comment">// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">    <span class="comment">// Do whatever you want</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消息机制流程"><a href="#消息机制流程" class="headerlink" title="消息机制流程"></a>消息机制流程</h3><p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fspqy7wqbyj20sg0lcap3.jpg" alt=""></p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super底层会转换为objc_msgSendSuper2函数的调用，接收2个参数</p>
<ul>
<li>struct objc_super2</li>
<li>SEL</li>
</ul>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> &#123;</span></div><div class="line">    id receiver;    	  <span class="comment">// receiver是消息接收者</span></div><div class="line">    Class current_class;  <span class="comment">// current_class是receiver的Class对象</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 摘自 objc4-723 Apple 开源 OC 源代码</span></div></pre></td></tr></table></figure>
<p><strong>看一道<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#21-下面的代码输出什么" target="_blank" rel="external">招聘一个靠谱的iOS</a>上的面试题</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的代码打印什么？</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// [self class] 根据消息机制可以转换成以下代码</span></div><div class="line">objc_msgSend(self, sel_registerName(<span class="string">"class"</span>));</div></pre></td></tr></table></figure>
<p>当调用<code>[self class]</code> 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></div><div class="line">   <span class="keyword">return</span> object_getClass(self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// [super class] 根据super底层实现可以转换成以下代码</span></div><div class="line">objc_msgSendSuper2(&#123;</div><div class="line">                    self,</div><div class="line">                    class_getSuperclass(current_class)</div><div class="line">                   &#125;,</div><div class="line">                   sel_registerName(<span class="string">"class"</span>));</div></pre></td></tr></table></figure>
<p>当调用<code>[super class]</code> 时,实际先调用的是 <code>objc_msgSendSuper2</code>函数，第一步先构造 <code>objc_super2</code> 结构体，第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(receiver, @selector(class))</code>去调用，因为<code>receiver =  self</code>,此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>
<p><strong>在看一道面试题</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的代码输出什么？</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSObject</span> isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSObject</span> isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [Person isKindOfClass:[Person <span class="keyword">class</span>]]);</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [Person isMemberOfClass:[Person <span class="keyword">class</span>]]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    <span class="keyword">return</span> [self class] == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    <span class="keyword">return</span> object_getClass((id)self) == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果为<code>1，0，0，0</code>。</p>
<p><strong>+isMemberOfClass:</strong>方法判断的方法调用者的类和方法参数中的类是否相等，NSObjec类调用object_getClass，得到的是NSObjec元类，Person也是同样道理，拿类和元类相比自然不想等，所以第二和第四个打印为false.</p>
<p><strong>+(BOOL)isKindOfClass:</strong>方法判断的方法调用者的类的本身及其父类和方法参数中的类是否有相等的，可知NSObjec的原类的superclass指向NSObjec类，所以<code>[NSObject isKindOfClass:[NSObject class]]</code>为true。而<code>[Person isKindOfClass:[Person class]]</code>Person的元类是meta-Person，meta-Person本身和父类中都是元类，所以不会有相等的。</p>
<h2 id="Runtime-API"><a href="#Runtime-API" class="headerlink" title="Runtime API"></a>Runtime API</h2><h3 id="类-API"><a href="#类-API" class="headerlink" title="类 API"></a>类 API</h3><ul>
<li><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>注册一个类（要在类注册之前添加成员变量）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>销毁一个类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>获取isa指向的Class</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>设置isa指向的Class</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>判断一个OC对象是否为Class</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">object_isClass</span><span class="params">(id obj)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>判断一个Class是否为元类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>获取父类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="成员变量-API"><a href="#成员变量-API" class="headerlink" title="成员变量 API"></a>成员变量 API</h3><ul>
<li><p>获取一个实例变量信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>拷贝实例变量列表（最后需要调用free释放）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>设置和获取成员变量的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span></div><div class="line">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span></div></pre></td></tr></table></figure>
</li>
<li><p>动态添加成员变量（已经注册的类是不能动态添加成员变量的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">size_t</span> size, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> * types)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>获取成员变量的相关信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar v)</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar v)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性-API"><a href="#属性-API" class="headerlink" title="属性 API"></a>属性 API</h3><ul>
<li><p>获取一个属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝属性列表（最后需要调用free释放）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div></pre></td></tr></table></figure>
</li>
<li><p>动态添加属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="function">BOOL <span class="title">class_addProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes,<span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>动态替换属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes,<span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>获取属性的一些信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="方法-API"><a href="#方法-API" class="headerlink" title="方法 API"></a>方法 API</h3><ul>
<li><p>获得一个实例方法、类方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span><span class="params">(Class cls, SEL name)</span></span></div><div class="line">Method <span class="title">class_getClassMethod</span><span class="params">(Class cls, SEL name)</span></div></pre></td></tr></table></figure>
</li>
<li><p>方法实现相关操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span> </span></div><div class="line">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></div><div class="line"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></div></pre></td></tr></table></figure>
</li>
<li><p>拷贝方法列表（最后需要调用free释放）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Method *<span class="title">class_copyMethodList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>动态添加方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>动态替换方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>获取方法的相关信息（带有copy的需要调用free去释放）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span></div><div class="line">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></div><div class="line"><span class="keyword">char</span> *<span class="title">method_copyReturnType</span><span class="params">(Method m)</span></div><div class="line"><span class="keyword">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></div></pre></td></tr></table></figure>
</li>
<li><p>选择器相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span></div><div class="line">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></div></pre></td></tr></table></figure>
</li>
<li><p>用block作为方法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span></div><div class="line">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></div><div class="line">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Runtime-应用场景"><a href="#Runtime-应用场景" class="headerlink" title="Runtime 应用场景"></a>Runtime 应用场景</h2><ul>
<li>利用关联对象（AssociatedObject）给分类添加属性</li>
<li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li>
<li>交换方法实现（交换系统的方法）</li>
<li>利用消息转发机制解决方法找不到的异常问题</li>
<li>……</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行。</p>
<p>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数，平时编写的OC代码，底层都是转换成了Runtime API进行调用。</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC Blocks 学习笔记]]></title>
      <url>/2018/06/14/OC-Blocks-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="什么是Blocks"><a href="#什么是Blocks" class="headerlink" title="什么是Blocks"></a>什么是Blocks</h2><p>从语法上看Blocks是带有自动变量（局部变量）的匿名函数，从底层结构上看Blocks本质上也是封装了函数调用以及函数调用环境的OC对象。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^blockName)(<span class="keyword">void</span>) = ^()&#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I am block"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是一个简单的Block，<code>void (^blockName)(void)</code> 声明了Block的返回值/名称/参数，<code>^(){NSLog(@&quot;I am block&quot;);};</code>是Block的具体实现，可以看作是一个没有名称的函数，只是比函数多了一个<code>^</code>。</p>
<h3 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h3><p>Block中，Block表达式截获所使用的自动变量的值，即保存该自动变量的瞬间值。因为Block表达式保存了自动变量的值，所以在执行Block语法后，即使改写Block中使用的自动变量的值也不会影响Block执行时自动变量的值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> value = <span class="number">10</span>;</div><div class="line"><span class="keyword">void</span> (^blockName)(<span class="keyword">void</span>) = ^()&#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"value = %d"</span>,value);</div><div class="line">&#125;;</div><div class="line">value = <span class="number">20</span>;</div><div class="line">blockName();</div><div class="line"></div><div class="line"><span class="comment">// 打印结果是10，而非20</span></div></pre></td></tr></table></figure>
<p>“<strong><em>带有自动变量（局部变量）的匿名函数</em></strong>”的定义中，<strong>带有自动变量</strong>是指Block拥有捕获外部变量的功能，在Block中访问一个外部的自动变量时，Block会持用它的临时状态，自动捕获变量值，外部自动变量的变化不会影响它的的状态，所以打印结果是10，而非20。</p>
<a id="more"></a>
<p>C语言中当我们声明一个局部变量不添加任何修饰符时，会默认变量为自动变量，相当于添加了<code>auto</code>关键字。这里需要区分自动变量和静态局部变量，静态变量会使用<code>static</code>做修饰。但只要是局部变量就会被截获到Block内部，但访问的方式不同（方式不同具体介绍可见下文）。</p>
<blockquote>
<p>自动变量属于动态存储类型，是在动态存储区内分配存储单元的，函数调用结束后存储单元即被释放。而静态局部变量是在静态存储区内分配内存单元，在程序的整个运行期间内都不释放空间。</p>
<p>所以我们在重用<code>UITableViewCell</code>时，常常用静态局部变量修饰<code>CellIdentifier</code>。</p>
</blockquote>
<p>需要注意的是，不能直接在Block的实现中，给自动变量赋值，不然会报以下错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量不可分配(缺少__block类型说明符)</span></div><div class="line">Variable is not assignable (missing __block type specifier)</div></pre></td></tr></table></figure>
<p>可以用<code>__block</code>说明符修饰自动变量，这时自动变量将会变Block内部的成员变量，并且进行内存管理，即可对其赋值，关于<code>__block</code>说明符具体介绍可见下文。</p>
<h2 id="Blocks底层结构"><a href="#Blocks底层结构" class="headerlink" title="Blocks底层结构"></a>Blocks底层结构</h2><p>我们可以使用clang(LLVM译码器)转换成C++源码，以此来窥探Block的实质。</p>
<p>在命令行工具（我这里用的是iTerm2）来到指定目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-11.0.0 main.m</div></pre></td></tr></table></figure>
<p>译成iOS 11 arm64 架构下的C++源码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以最简单了Block为例</span></div><div class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^()&#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"I am Block"</span>);</div><div class="line">&#125;;</div><div class="line">myBlock();</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最终转换成的 C++ 代码</span></div><div class="line"><span class="comment">// 已删除一些强制转换代码，Block无关代码转换成伪代码</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span> 	<span class="comment">// Block结构体</span></div><div class="line">    <span class="keyword">void</span> *isa;		    <span class="comment">// isa 指针</span></div><div class="line">    <span class="keyword">int</span> Flags;			<span class="comment">// 默认为0</span></div><div class="line">    <span class="keyword">int</span> Reserved;		<span class="comment">// 保留字段，暂时没用，可能以后会用到</span></div><div class="line">    <span class="keyword">void</span> *FuncPtr;		<span class="comment">// 执行函数指针</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span>  	<span class="comment">// myBlock 结构体,有意思的发现命名是从0开始递增，0、1、2...</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span>	<span class="comment">// C++ 特有语法，表示__main_block_impl_0拥有__block_impl4个成员变量</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span> <span class="comment">// myBlock 的描述信息</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;  <span class="comment">// isa 指针赋值</span></div><div class="line">        impl.Flags = flags; <span class="comment">// 默认为0</span></div><div class="line">        impl.FuncPtr = fp;  <span class="comment">// 执行函数指针</span></div><div class="line">        Desc = desc; <span class="comment">// 描述信息</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// myBlock的执行函数，__cself相当于C++中的this，OC中的self，就想OC方法会自带self和_cmd</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; </div><div class="line">    NSLog(@<span class="string">"I am Block"</span>); <span class="comment">// 源码并不是这样，但和文本讨论内容无关，所以可以理解为伪代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span> <span class="comment">// myBlock的描述</span></div><div class="line">    <span class="keyword">size_t</span> reserved;     <span class="comment">// 保留字段</span></div><div class="line">    <span class="keyword">size_t</span> Block_size;	 <span class="comment">// myBlock的内存大小</span></div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="comment">// myBlock的声明指向 __main_block_impl_0 结构体的内存地址</span></div><div class="line"><span class="comment">// __main_block_impl_0通过构造函数创建了一个myBlock对象</span></div><div class="line"><span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(</div><div class="line">                                             __main_block_func_0,      <span class="comment">// myBlock的执行函数地址</span></div><div class="line">                                             &amp;__main_block_desc_0_DATA <span class="comment">// myBlock的描述信息</span></div><div class="line">                                             );</div><div class="line"></div><div class="line"><span class="comment">// 调用时通过 myBlock 指针找到 __main_block_impl_0 中的执行函数指针，</span></div><div class="line"><span class="comment">// 执行函数指针找到函数的实现，再调用该函数，并且把自己作为参数传到函数内部</span></div><div class="line">myBlock-&gt;FuncPtr(myBlock);</div></pre></td></tr></table></figure>
<p>有源码可以总结到Block实则为以下结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">int</span> Flags;</div><div class="line">    <span class="keyword">int</span> Reserved;</div><div class="line">    <span class="keyword">void</span> *FuncPtr;        </div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此<code>__main_block_impl_0</code>结构体相当于基于<code>objc_object</code>结构体的OC类对象(<a href="http://renyijie.top/2018/05/11/OC%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">OC对象内存学习笔记</a>可查看OC类对象内存结构)。就此，可以理解“<strong><em>Blocks本质上也是封装了函数调用以及函数调用环境的OC对象</em></strong>”定义中，<strong>Blocks本质是OC对象</strong>的说法了。<code>void *FuncPtr;</code>成员变量了Block执行函数的调用地址，所以<strong>封装了函数调用</strong>也不言而喻了。</p>
<h3 id="截获变量值的本质"><a href="#截获变量值的本质" class="headerlink" title="截获变量值的本质"></a>截获变量值的本质</h3><p>上文中说到Block会截获所使用的自动变量的值，现在来具体看一下截获的本质。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> height = <span class="number">178</span>;  <span class="comment">// 全局变量</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        auto <span class="keyword">int</span> age = <span class="number">10</span>; 		<span class="comment">// 自动局部变量</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;	 <span class="comment">// 静态局部变量</span></div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^()&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"my age = %d"</span>, age);        <span class="comment">// 访问外部自动局部变量</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"my number = %d"</span>, number);  <span class="comment">// 访问外部静态局部变量</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"my height = %d"</span>, height);  <span class="comment">// 访问外部全局变量</span></div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最终转换成的 C++ 代码</span></div><div class="line"><span class="comment">// 已删除一些强制转换代码，Block无关代码转换成伪代码</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">      <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">      <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">      <span class="keyword">int</span> age;      <span class="comment">// 保存外部的自动局部变量的值</span></div><div class="line">      <span class="keyword">int</span> *number;  <span class="comment">// 保存外部的静态局部变量的指针</span></div><div class="line">      __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> *_number, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age), number(_number) &#123;</div><div class="line">          impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">          impl.Flags = flags;</div><div class="line">          impl.FuncPtr = fp;</div><div class="line">          Desc = desc;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <span class="keyword">int</span> age = <span class="number">10</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</div><div class="line"><span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(</div><div class="line">    									  __main_block_func_0, </div><div class="line">                                             &amp;__main_block_desc_0_DATA, </div><div class="line">                                             age, </div><div class="line">                                             &amp;number</div><div class="line">                                             );</div><div class="line"></div><div class="line">myBlock-&gt;FuncPtr(myBlock);</div></pre></td></tr></table></figure>
<p>首先我们注意到，Block语法表达式中使用的自动局部变量被作为成员变量追加到了__main_block_impl_0结构体中，而全局变量没有。并且自动局部变量保存的是值，而静态局部变量保存的是指针，想一想，静态局部变量并不会被销毁使用只需要保存地址，而自动局部变量有可能会在Block调用前已经销毁掉，所以需要保存其值。</p>
<p><strong>截获变量值总结如下</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">截获到Block内部</th>
<th style="text-align:center">访问方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自动局部变量（auto）</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">值传递</td>
</tr>
<tr>
<td style="text-align:center">静态局部变量（static）</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">指针传递</td>
</tr>
<tr>
<td style="text-align:center">全局变量</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">直接访问</td>
</tr>
</tbody>
</table>
<h3 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a>__block说明符</h3><p>上文提到在Block中修改自动局部变量的值时，编译器就报警告，要求用__block说明符。</p>
<p>首先来看一下允许Block中可以改写值的：</p>
<ul>
<li>局部静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>静态全局变量和全局变量的访问和赋值，与Block外完全相同。但局部静态变量是截获其内存地址，通过内存地址来访问和赋值。</p>
<p>由于自动局部变量会被截获到Block内部，并且Block结构体的就有一个成员变量来存储自动局部变量的值。我们先来看一下用__block修饰的自动局部变量被截获到内部后会怎么样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block auto <span class="keyword">int</span> age = <span class="number">10</span>;     <span class="comment">// __block 修饰的自动局部变量</span></div><div class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^()&#123;</div><div class="line">	<span class="keyword">int</span> value = age; 	<span class="comment">// 访问外部自动局部变量</span></div><div class="line">	age = <span class="number">30</span>;       	<span class="comment">// 给外部自动局部变量赋值</span></div><div class="line">&#125;;</div><div class="line">myBlock();</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最终转换成的 C++ 代码</span></div><div class="line"><span class="comment">// 已删除一些强制转换代码，Block无关代码转换成伪代码</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *__isa; <span class="comment">// 指针 为0</span></div><div class="line">    __Block_byref_age_0 *__forwarding; <span class="comment">// __Block_byref_age_0实例的内存地址</span></div><div class="line">    <span class="keyword">int</span> __flags; <span class="comment">// 0</span></div><div class="line">    <span class="keyword">int</span> __size;  <span class="comment">// 内存大小</span></div><div class="line">    <span class="keyword">int</span> age;     <span class="comment">// age相当于原自动局部变量的成员变量</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    __Block_byref_age_0 *age; <span class="comment">// 该指针指向 __block变量的__Block_byref_age_0结构体实例</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age-&gt;__forwarding) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    __Block_byref_age_0 *age = __cself-&gt;age;   <span class="comment">// 取出Block的age指针</span></div><div class="line">    <span class="keyword">int</span> value = (age-&gt;__forwarding-&gt;age);  <span class="comment">// 通过 __Block_byref_age_0 实例的__forwarding访问age</span></div><div class="line">    (age-&gt;__forwarding-&gt;age) = <span class="number">30</span>;         <span class="comment">// 因为 void *__isa 存的是0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;age, (<span class="keyword">void</span>*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 加了__block 后 age 成了结构体实例</span></div><div class="line"><span class="comment">// 该实例保存了 age的地址、初始值以及内存大小</span></div><div class="line">__attribute__((__blocks__(byref))) <span class="keyword">auto</span> __Block_byref_age_0 age = &#123;<span class="number">0</span>,</div><div class="line">            												   &amp;age,</div><div class="line">            												   <span class="number">0</span>,</div><div class="line">            												<span class="keyword">sizeof</span>(__Block_byref_age_0),</div><div class="line">                                                                   <span class="number">10</span>&#125;;</div><div class="line"><span class="comment">// Block内部将__Block_byref_age_0结构体实例作为成员变量保存</span></div><div class="line"><span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</div><div class="line">                                             &amp;__main_block_desc_0_DATA,</div><div class="line">                                             &amp;age,</div><div class="line">                                             <span class="number">570425344</span>));</div><div class="line">myBlock-&gt;FuncPtr(myBlock);</div></pre></td></tr></table></figure>
<p>Block_byref_age_0 结构体实例的成员变量<strong>forwarding持有指向该实例自身的指针，可以实现无论<strong>block变量配置在栈上还是堆上都能正确地访问</strong>block变量，也就是说</strong>forwarding是指向自身的。</p>
<p>怎么实现的？</p>
<ul>
<li>最初，<strong>block变量在栈上时，它的成员变量</strong>forwarding指向栈上的__block变量结构体实例。</li>
<li>在<strong>block被复制到堆上时，会将</strong>forwarding的值替换为堆上的目标<strong>block变量用结构体实例的地址。而在堆上的目标</strong>block变量自己的__forwarding的值就指向它自己。</li>
</ul>
<h3 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [block <span class="keyword">class</span>]);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[block <span class="keyword">class</span>] superclass]);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[block <span class="keyword">class</span>] superclass] superclass]);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[[block <span class="keyword">class</span>] superclass] superclass] superclass]);</div><div class="line"></div><div class="line"><span class="comment">// 运行结果如下：</span></div><div class="line"><span class="comment">// __NSGlobalBlock__</span></div><div class="line"><span class="comment">// __NSGlobalBlock</span></div><div class="line"><span class="comment">// NSBlock</span></div><div class="line"><span class="comment">// NSObject</span></div></pre></td></tr></table></figure>
<p>首先，可见Block即成自NSObject，这边可以再次验证了Block本质是对象。（之前从Block结构体已经确认）</p>
<p><strong>__NSGlobalBlock又是什么鬼？</strong></p>
<p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）<span class="comment">// 内存：数据区域 .data 区</span></div><div class="line">__NSStackBlock__ （ _NSConcreteStackBlock ）  <span class="comment">// 内存：栈区</span></div><div class="line">__NSMallocBlock__ （ _NSConcreteMallocBlock ）<span class="comment">// 内存：堆区</span></div></pre></td></tr></table></figure>
<blockquote>
<p>堆：动态分配内存,需要程序员申请申请，也需要程序员自己管理内存</p>
</blockquote>
<p>之前在 __main_block_impl_0 结构体中isa赋值时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^()&#123;</div><div class="line">	NSLog(@<span class="string">"I am Block"</span>);</div><div class="line">&#125;;</div><div class="line">myBlock();</div><div class="line"></div><div class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">	impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">	impl.Flags = flags; </div><div class="line">	impl.FuncPtr = fp;  </div><div class="line">	Desc = desc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见myBlock为<code>__NSGlobalBlock__</code>类型的Block。</p>
<p><strong>三种类型生成的环境</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">block类型</th>
<th style="text-align:center">环境</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__NSGlobalBlock__</code></td>
<td style="text-align:center">没有访问auto变量</td>
</tr>
<tr>
<td style="text-align:center"><code>__NSStackBlock__</code></td>
<td style="text-align:center">访问了auto变量</td>
</tr>
<tr>
<td style="text-align:center"><code>__NSMallocBlock__</code></td>
<td style="text-align:center"><code>__NSStackBlock__</code>调用了copy</td>
</tr>
</tbody>
</table>
<p><strong>每一种类型的block调用copy后的结果如下所示</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">block的类</th>
<th style="text-align:center">副本源的配置存储域</th>
<th style="text-align:center">复制效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_NSConcreteGlobalBlock</td>
<td style="text-align:center">程序的数据区域</td>
<td style="text-align:center">什么也不做</td>
</tr>
<tr>
<td style="text-align:center">_NSConcreteStackBlock</td>
<td style="text-align:center">栈</td>
<td style="text-align:center">从栈复制到堆</td>
</tr>
<tr>
<td style="text-align:center">_NSConcreteMallocBlock</td>
<td style="text-align:center">堆</td>
<td style="text-align:center">引用计数增加</td>
</tr>
</tbody>
</table>
<p>而大多数情况下，编译器会进行判断，自动将block从栈上复制到堆：</p>
<ul>
<li>block作为函数值返回的时候</li>
<li>部分情况下向方法或函数中传递block的时候<ul>
<li>Cocoa框架的方法而且方法名中含有usingBlock等时。</li>
<li>Grand Central Dispatch 的API。</li>
</ul>
</li>
</ul>
<p>除了这两种情况，基本都需要我们手动复制block。</p>
<p>那么__block变量在Block执行copy操作后会发生什么呢？</p>
<ol>
<li>任何一个block被复制到堆上时，__block变量也会一并从栈复制到堆上，并被该Block持有。</li>
<li>如果接着有其他Block被复制到堆上的话，被复制的Block会持有<strong>block变量，并增加</strong>block的引用计数，反过来如果Block被废弃，它所持有的__block也就被释放（不再有block引用它）。</li>
</ol>
<h3 id="copy和dispose"><a href="#copy和dispose" class="headerlink" title="copy和dispose"></a>copy和dispose</h3><p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况</p>
<ul>
<li>block作为函数返回值时</li>
<li>将block赋值给__strong指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ul>
<p>被__block说明符修饰后，会把自动变量包装成对象处理，同时多了两个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;age, (<span class="keyword">void</span>*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div></pre></td></tr></table></figure>
<p><strong>如果block被拷贝到堆上</strong></p>
<ul>
<li><p>会调用block内部的copy函数</p>
</li>
<li><p>copy函数内部会调用_Block_object_assign函数</p>
</li>
<li><p>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>、<code>__weak</code>、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用​</p>
</li>
</ul>
<p><strong>如果block从堆上移除</strong></p>
<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的auto变量（release）</li>
</ul>
<h3 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h3><p>如果在Block内部使用__strong修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有。</p>
<p>所以如果这个对象还同时持有Block的话，就容易发生循环引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    blk_t blk_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        blk_ = ^&#123;</div><div class="line">        	<span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,<span class="keyword">self</span>);</div><div class="line">    	&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>Block blk_t持有self，而self也同时持有作为成员变量的blk_t</p>
<p><strong>__weak修饰符</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</div><div class="line">    	blk_ = ^&#123;</div><div class="line">        	<span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,weakSelf);</div><div class="line">    	&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    blk_t blk_;</div><div class="line">    <span class="keyword">id</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        blk_ = ^&#123;</div><div class="line">        	<span class="built_in">NSLog</span>(<span class="string">@"obj_ = %@"</span>,obj_);<span class="comment">//循环引用警告</span></div><div class="line">    	&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Block语法内的obj<em>截获了self,因为ojb</em>是self的成员变量，因此，block如果想持有obj_，就必须引用先引用self，所以同样会造成循环引用。就好比你如果想去某个商场里的咖啡厅，就需要先知道商场在哪里一样。</p>
<p>如果某个属性用的是weak关键字呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        blk_ = ^&#123;</div><div class="line">        	<span class="built_in">NSLog</span>(<span class="string">@"array = %@"</span>,_array);<span class="comment">//循环引用警告</span></div><div class="line">    	&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是会有循环引用的警告提示，因为循环引用的是self和block之间的事情，这个被Block持有的成员变量是strong还是weak都没有关系,而且即使是基本类型（assign）也是一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> index;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"index = %ld"</span>,_index);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>__block修饰符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    __block id temp = self;//temp持有self</div><div class="line">    </div><div class="line">    //self持有blk_</div><div class="line">    blk_ = ^&#123;</div><div class="line">        NSLog(@&quot;self = %@&quot;,temp);//blk_持有temp</div><div class="line">        temp = nil;</div><div class="line">    &#125;;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)execBlc</div><div class="line">&#123;</div><div class="line">    blk_();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以如果不执行blk_（将temp设为nil），则无法打破这个循环。</p>
<p>一旦执行了blk_，就只有</p>
<ul>
<li>self持有blk_</li>
<li>blk_持有temp</li>
</ul>
<p>使用__block 避免循环比较有什么特点呢？</p>
<ul>
<li>通过__block可以控制对象的持有时间。</li>
<li>为了避免循环引用必须执行block，否则循环引用一直存在。</li>
</ul>
<p>所以我们应该根据实际情况，根据当前Block的用途来决定到底用<strong>block，还是</strong>weak或__unsafe_unretained。</p>
<h2 id="Blocks语法"><a href="#Blocks语法" class="headerlink" title="Blocks语法"></a>Blocks语法</h2><ul>
<li><code>returnType</code> 表示返回的对象/关键字等(可以是void，并省略)</li>
<li><code>blockName</code> 表示block的名称</li>
<li><code>parameterTypes</code> 表示参数的类型(可以是void，并省略)</li>
<li><code>parameters</code> 表示参数</li>
</ul>
<h3 id="作为局部变量"><a href="#作为局部变量" class="headerlink" title="作为局部变量"></a>作为局部变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回值类型(^名称)(参数的类型) = ^返回值类型(参数) &#123;...&#125;</span></div><div class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 省略返回值类型 &amp; 参数的类型</span></div><div class="line"><span class="keyword">void</span> (^blockName)(<span class="keyword">void</span>) = ^<span class="keyword">void</span>(<span class="keyword">void</span>) &#123;...&#125;; </div><div class="line"><span class="comment">// 也可以省略block实现中的void，更加精简的写法</span></div><div class="line"><span class="keyword">void</span> (^blockName)(<span class="keyword">void</span>) = ^() &#123;...&#125;;</div></pre></td></tr></table></figure>
<p><strong>For example</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明并实现一个局部变量Block</span></div><div class="line"><span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 调用局部变量Block</span></div><div class="line"><span class="keyword">int</span> results = addBlock(<span class="number">1</span>,<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h3 id="作为属性"><a href="#作为属性" class="headerlink" title="作为属性"></a>作为属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法相当于作为局部变量时的声明，作为属性后升级为全局变量</span></div><div class="line"><span class="comment">// 返回值类型(^名称)(参数的类型)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, nullability) returnType (^blockName)(parameterTypes);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里使用了<code>copy</code>修饰符，<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#3-怎么用-copy-关键字" target="_blank" rel="external">why？</a></p>
</blockquote>
<p><strong>For example</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将上一个例子中的局部变量升级为全局变量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>);</div><div class="line"></div><div class="line"><span class="comment">// 实现全局变量</span></div><div class="line">_addBlock = ^<span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</div><div class="line">	<span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 调用局部变量Block</span></div><div class="line"><span class="keyword">int</span> results = addBlock(<span class="number">1</span>,<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h3 id="作为方法参数-方法调用的参数"><a href="#作为方法参数-方法调用的参数" class="headerlink" title="作为方法参数/方法调用的参数"></a>作为方法参数/方法调用的参数</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回值类型(^)(参数的类型) </span></div><div class="line">- (<span class="keyword">void</span>)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</div><div class="line"></div><div class="line"><span class="comment">// ^返回值类型(参数)</span></div><div class="line">[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];</div></pre></td></tr></table></figure>
<p><strong>For example</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上一个例子中的属性，会自动生成一个Set方法</span></div><div class="line">- (<span class="keyword">void</span>)setAddBlock:(<span class="keyword">int</span> (^)(<span class="keyword">int</span>, <span class="keyword">int</span>))addBlock;</div><div class="line"></div><div class="line"><span class="comment">// 调用方法</span></div><div class="line">[<span class="keyword">self</span> setAddBlock:^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</div><div class="line">	<span class="keyword">return</span> a + b;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 可见在定义方法时，Block作为形参</span></div><div class="line"><span class="comment">// 在调用方法时，Block作为实参</span></div></pre></td></tr></table></figure>
<h3 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回值类型(^)(参数的类型)</span></div><div class="line">- (returnType(^nullability)(parameterTypes))methodName;</div></pre></td></tr></table></figure>
<p><strong>For example</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 依旧是之前作为属性的Block</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">int</span>(^addBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>);</div><div class="line"></div><div class="line"><span class="comment">// 该属性的 Get 方法</span></div><div class="line">- (<span class="keyword">int</span> (^)(<span class="keyword">int</span>, <span class="keyword">int</span>))addBlock &#123;</div><div class="line">    <span class="keyword">return</span> _addBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在链式编程时，核心就是将Block作为返回值，达到链式调用的效果。</p>
</blockquote>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><blockquote>
<p>typedef是C中的关键字，它的主要作用是给一个数据类型定义一个新的名称</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// typedef 返回值类型 (^类型名称)(参数类型);</span></div><div class="line"><span class="keyword">typedef</span> returnType (^TypeName)(parameterTypes);</div><div class="line"></div><div class="line"><span class="comment">// 类型名称 block名称 = ^返回值类型(参数) &#123;...&#125;;</span></div><div class="line">TypeName blockName = ^returnType(parameters) &#123;...&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>在Xcode中键入typedefBlock,即可快速生成语法 </p>
</blockquote>
<p><strong>For example</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个 Block 类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^RYJAddBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</div><div class="line"></div><div class="line"><span class="comment">// 声明 Block 属性</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) RYJAddBlock addBlock;</div><div class="line"></div><div class="line"><span class="comment">// 给_addBlock成员变量赋值</span></div><div class="line">_addBlock = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</div><div class="line">	<span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>⚠️在声明 Block 时往往只声明参数类型，但在一些知名第三方，以及Apple官方的一些写法中，会声明参数名称，个人认为这样会使代码更加便于阅读，所以建议在声明Block时声明完整的参数类型及其名称。</p>
</blockquote>
<h2 id="Block应用场景"><a href="#Block应用场景" class="headerlink" title="Block应用场景"></a>Block应用场景</h2><h3 id="事件回调-amp-数据传递"><a href="#事件回调-amp-数据传递" class="headerlink" title="事件回调 &amp; 数据传递"></a>事件回调 &amp; 数据传递</h3><p>时间回调和数据传递通常会一起使用，For example</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">                              progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</div><div class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure</div></pre></td></tr></table></figure>
<p>AFNetworking框架中Get请求的回调，同时传递请求到的数据。</p>
<p>我们也可以单独使用事件回调</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^RYJWeekDaysUpdateBlock)(<span class="keyword">void</span>);</div><div class="line"><span class="comment">// 声明一个Block</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) RYJWeekDaysUpdateBlock weekDaysUpdate;</div><div class="line"><span class="comment">// 在恰当时间回调</span></div><div class="line"><span class="keyword">if</span> (_weekDaysUpdate) &#123;</div><div class="line">	_weekDaysUpdate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现Block</span></div><div class="line">weekDaysUpdate = ^&#123;</div><div class="line">	<span class="comment">// DO SOMETHING...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以是事件回调还是数据传递，需要根据需求判断。</p>
<h3 id="链式语法"><a href="#链式语法" class="headerlink" title="链式语法"></a>链式语法</h3><blockquote>
<p><strong>链式编程思想</strong>：核心思想为将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，这样就可以实现了连续调用，即为链式编程。</p>
</blockquote>
<p>Masonry的一个典型的链式编程用法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">	make.left.equalTo(<span class="keyword">self</span>.mas_left).mas_offset(<span class="number">110</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.amazon.cn/dp/B00DE60G3S/ref=sr_1_fkmr0_1?ie=UTF8&amp;qid=1528769313&amp;sr=8-1-fkmr0&amp;keywords=Objective-C+高级编程+iOS与OSX多线程和内存管理" target="_blank" rel="external">《Objective-C 高级编程 iOS与OSX多线程和内存管理》</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1" target="_blank" rel="external">《Blocks Programming Topics》</a></p>
<p><a href="http://fuckingblocksyntax.com" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC对象内存学习笔记]]></title>
      <url>/2018/05/11/OC%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="实例对象（instance对象）"><a href="#实例对象（instance对象）" class="headerlink" title="实例对象（instance对象）"></a>实例对象（instance对象）</h2><h3 id="NSObject对象创建时内存分配"><a href="#NSObject对象创建时内存分配" class="headerlink" title="NSObject对象创建时内存分配"></a>NSObject对象创建时内存分配</h3><p>NSObject的底层实现，实质上是一个结构体指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> &#123;</span></div><div class="line">	Class isa;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>初始化一个NSObject对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p><code>NSObject 类</code>调用<code>alloc类方法</code>，会向内存中申请16个字节，用来存放<code>isa指针</code>，但只占用8个字节（isa指针为8个字节）。<code>object对象</code>指向这块内存地址。</p>
<blockquote>
<p>可以通过 Xcode -&gt;Debug-&gt;View Memory 直接看内存</p>
<p>也可以通过LLDB指令读取内存</p>
<p>获取内存大小请看<a href="#获取内存大小">这里</a></p>
</blockquote>
<a id="more"></a>
<h3 id="Student对象创建时内存分配"><a href="#Student对象创建时内存分配" class="headerlink" title="Student对象创建时内存分配"></a>Student对象创建时内存分配</h3><p>自定义一个继承NSObject类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">@public</span></div><div class="line">    <span class="keyword">int</span> _no;</div><div class="line">    <span class="keyword">int</span> _age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转成C代码后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_IMPL</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></div><div class="line">    <span class="keyword">int</span> _no;</div><div class="line">    <span class="keyword">int</span> _age;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> &#123;</span></div><div class="line">	Class isa;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>初始化一个Student对象，并赋值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Student *stu = [[Student alloc] init];</div><div class="line">stu-&gt;_no = <span class="number">4</span>;</div><div class="line">stu-&gt;_age = <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p><code>[Student alloc]</code>会向内存申请16个字节，前8个字节存isa指针，后8个字节存自己的成员变量的值。</p>
<h3 id="成员变量和属性的区别"><a href="#成员变量和属性的区别" class="headerlink" title="成员变量和属性的区别"></a>成员变量和属性的区别</h3><p>属性 = 成员变量（ivar） + setter方法 + getter方法</p>
<p>⚠️对象内存中只存成员变量不存方法（无论是实例方法还是对象方法），方法每个实例对象都一样，所以只需要存一份，不放在对象内存中。</p>
<h3 id="实例对象的内存布局图"><a href="#实例对象的内存布局图" class="headerlink" title="实例对象的内存布局图"></a>实例对象的内存布局图</h3><p>isa 指向其类对象，其余空间保存各级的 ivar（成员变量）</p>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fr519wdwa5j205z0ecq42.jpg" alt=""></p>
<p>图片来自<a href="https://blog.csdn.net/xiaolinyeyi/article/details/51393383" target="_blank" rel="external">OC对象的内存布局</a></p>
<h2 id="类对象（class对象）"><a href="#类对象（class对象）" class="headerlink" title="类对象（class对象）"></a>类对象（class对象）</h2><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *object1 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="comment">// 通过对象方法获取</span></div><div class="line">Class objectClass1 = [object1 <span class="keyword">class</span>];</div><div class="line"><span class="comment">// Runtime API</span></div><div class="line">Class objectClass2 = object_getClass(object1); </div><div class="line"><span class="comment">// 通过类方法获取</span></div><div class="line">Class objectClass3 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</div></pre></td></tr></table></figure>
<h3 id="类对象内存布局"><a href="#类对象内存布局" class="headerlink" title="类对象内存布局"></a>类对象内存布局</h3><p>每个类在内存中有且只有一个class对象</p>
<p>class对象在内存中存储的信息主要包括：</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的属性信息（@property）、类的对象方法信息（instance method）</li>
<li>类的协议信息（protocol）、类的成员变量信息（ivar）</li>
<li>…</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 摘自objc4-723开源源码</span></div><div class="line"></div><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</div><div class="line">    <span class="comment">// Class ISA;</span></div><div class="line">    Class superclass;</div><div class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable(方法缓存)</span></div><div class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags（获取具体的类信息）</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></div><div class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></div><div class="line">    <span class="keyword">uint32_t</span> flags;</div><div class="line">    <span class="keyword">uint32_t</span> version;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</div><div class="line"></div><div class="line">    <span class="keyword">method_array_t</span> methods;		    <span class="comment">// 方法列表</span></div><div class="line">    <span class="keyword">property_array_t</span> properties;	<span class="comment">// 属性列表</span></div><div class="line">    <span class="keyword">protocol_array_t</span> protocols;		<span class="comment">// 协议列表</span></div><div class="line"></div><div class="line">    Class firstSubclass;</div><div class="line">    Class nextSiblingClass;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *demangledName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> flags;</div><div class="line">    <span class="keyword">uint32_t</span> instanceStart;</div><div class="line">    <span class="keyword">uint32_t</span> instanceSize;  <span class="comment">// 实例对象占用的内存大小</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">uint32_t</span> reserved;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</div><div class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</div><div class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;  <span class="comment">// 成员变量列表</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</div><div class="line">    <span class="keyword">property_list_t</span> *baseProperties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="类对象的内存布局图"><a href="#类对象的内存布局图" class="headerlink" title="类对象的内存布局图"></a>类对象的内存布局图</h3><p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fr73pruj5uj206b0bm0sq.jpg" alt=""></p>
<h2 id="元类对象（meta-class对象）"><a href="#元类对象（meta-class对象）" class="headerlink" title="元类对象（meta-class对象）"></a>元类对象（meta-class对象）</h2><h3 id="获取元类方法"><a href="#获取元类方法" class="headerlink" title="获取元类方法"></a>获取元类方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Runtime API</span></div><div class="line">Class objectMetaClass = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div><div class="line"><span class="comment">// ⚠️这种方式获取到的始终是类对象，而非原类对象</span></div><div class="line">Class objectMetaClass2 = [[[<span class="built_in">NSObject</span> <span class="keyword">class</span>] <span class="keyword">class</span>] <span class="keyword">class</span>];</div><div class="line"><span class="comment">// Runtime 还有一个函数可以判断是否是元类对象</span></div><div class="line">class_isMetaClass(objectMetaClass)</div></pre></td></tr></table></figure>
<h3 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h3><p>每个类在内存中有且只有一个meta-class对象</p>
<p>meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的类方法信息（class method）</li>
<li>…</li>
</ul>
<h2 id="经典总结"><a href="#经典总结" class="headerlink" title="经典总结"></a>经典总结</h2><p><strong>1.instance的isa指向class</strong></p>
<p><strong>2.class的isa指向meta-class</strong></p>
<p><strong>3.meta-class的isa指向基类的meta-class</strong></p>
<p><strong>4.class的superclass指向父类的class</strong></p>
<blockquote>
<p>如果没有父类，superclass指针为nil</p>
</blockquote>
<p><strong>5.meta-class的superclass指向父类的meta-class</strong></p>
<blockquote>
<p>基类的meta-class的superclass指向基类的class</p>
</blockquote>
<p><strong>6.instance调用对象方法的轨迹</strong></p>
<blockquote>
<p>isa找到class，方法不存在，就通过superclass找父类</p>
</blockquote>
<p><strong>7.class调用类方法的轨迹</strong></p>
<blockquote>
<p>isa找meta-class，方法不存在，就通过superclass找父类</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fr74nfi2g2j20ch0d1gn1.jpg" alt=""></p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="OC堆和栈"><a href="#OC堆和栈" class="headerlink" title="OC堆和栈"></a>OC堆和栈</h3><ul>
<li>OC对象存放于堆里面(堆内存要程序员手动回收)</li>
<li>非OC对象一般放在栈里面(栈内存会被系统自动回收)</li>
</ul>
<blockquote>
<p>堆里面的内存是动态分配的，所以也就需要程序员手动的去添加内存、回收内存</p>
<p>栈里面存放的是非对象的基本数据类型，堆内存存放着OC对象</p>
</blockquote>
<p>摘自<a href="https://www.jianshu.com/p/c8e1d91dda99" target="_blank" rel="external">iOS 堆和栈的区别</a></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实例化 object 对象</span></div><div class="line"><span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>object 指针存在栈区，指向的是堆区实例对象isa的地址。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 实例化 xiaoMing 对象</span></div><div class="line">Student *xiaoMing = [[Student alloc] init];</div><div class="line">xiaoMing.object = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>这时候 object 指针是存在堆区，因为 object 作为 Student 类的成员变量，在实例化后xiaoMing这个对象会存在堆区。也就是 object 指针会从堆区指向堆区。</p>
<p><a href="https://blog.csdn.net/bryantsikilovia/article/details/46336957" target="_blank" rel="external">OC的指针是什么</a></p>
<h3 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h3><p>无论是实例对象、类对象还是元类对象，都有isa指针，isa在方法调用起到至关重要的作用。</p>
<blockquote>
<p>OC的消息发送机制，给对象发送消息时没有对象方法和类方法之分。</p>
</blockquote>
<p><strong>实例对象的isa指向类对象的内存地址</strong></p>
<ul>
<li>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</li>
</ul>
<p><strong>类对象的isa指向元类对象的内存地址</strong></p>
<ul>
<li>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用</li>
</ul>
<p><strong>元类对象的isa指向ROOT元类对象，ROOT元类对象的isa指向自己的内存地址</strong></p>
<h4 id="isa计算"><a href="#isa计算" class="headerlink" title="isa计算"></a>isa计算</h4><p>从64bit开始，isa需要进行一次位运算（&amp; ISA_MASK），才能计算出真实地址</p>
<blockquote>
<p>即，实例对象的isa存的地址&amp; ISA_MASK，才能得出类对象的内存地址。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 摘自objc4-723开源源码</span></div><div class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></div><div class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></div><div class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><h3 id="获取内存大小"><a href="#获取内存大小" class="headerlink" title="获取内存大小"></a>获取内存大小</h3><p><span id="获取内存大小"></span></p>
<ul>
<li>创建一个实例对象，至少需要多少内存</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line">class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div></pre></td></tr></table></figure>
<ul>
<li>创建一个实例对象，实际上分配了多少内存</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line">malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)obj);</div></pre></td></tr></table></figure>
<ul>
<li>获取一个表达式或类型的内存大小（在编译阶段已经完成计算）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sizeof(expression-or-type)</div></pre></td></tr></table></figure>
<h2 id="底层研究"><a href="#底层研究" class="headerlink" title="底层研究"></a>底层研究</h2><h3 id="OC代码转成C-C-代码"><a href="#OC代码转成C-C-代码" class="headerlink" title="OC代码转成C/C++代码"></a>OC代码转成C/C++代码</h3><p>OC的底层实现是C和C++，在研究底层的对象时，需要转成C和C++代码，以便理解其原理。</p>
<p><strong>将OC代码转成C/C++代码</strong></p>
<ul>
<li><p>用命令行工具定位到该OC代码文件</p>
</li>
<li><p>运行命令<code>clang -rewrite-objc main.m -o main.c</code></p>
<blockquote>
<p>mian.m为OC文件，main.c转成的C文件。如果要转成C++，就用cpp后缀，mian.cpp</p>
</blockquote>
</li>
</ul>
<p><strong>将OC代码转成指定平台C/C++代码</strong></p>
<ul>
<li><p>用命令行工具定位到该OC代码文件</p>
</li>
<li><p>运行命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mian-arm64.cpp</code></p>
<blockquote>
<p>模拟器(i386)、32bit(armv7)、64bit(arm64）</p>
</blockquote>
</li>
</ul>
<h3 id="Apple开源源码地址"><a href="#Apple开源源码地址" class="headerlink" title="Apple开源源码地址"></a><a href="https://opensource.apple.com/tarballs" target="_blank" rel="external">Apple开源源码地址</a></h3><p>研究一些OC提供的数据类型/方法/…时，可以直接看源码。</p>
<p>需要C++和C的基础。</p>
<h3 id="LLDB常用指令"><a href="#LLDB常用指令" class="headerlink" title="LLDB常用指令"></a>LLDB常用指令</h3><p><a href="http://www.dreamingwish.com/article/lldb-usage-a.html" target="_blank" rel="external">LLDB使用篇</a></p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="位、字节、字、KB"><a href="#位、字节、字、KB" class="headerlink" title="位、字节、字、KB"></a>位、字节、字、KB</h3><ul>
<li>位：”位(bit)”是电子计算机中最小的数据单位。每一位的状态只能是0或1。</li>
<li>字节：8个二进制位构成1个”字节(Byte)”，它是存储空间的基本计量单位。1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。</li>
<li>字：”字”由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。</li>
<li>KB：1KB表示1K个Byte，也就是1024个字节。</li>
</ul>
<blockquote>
<p>1KB = 1024 Bytes = 8192 Bits</p>
<p>2个16进制“位” = 1个字节</p>
</blockquote>
<h3 id="小端模式-amp-大端模式"><a href="#小端模式-amp-大端模式" class="headerlink" title="小端模式&amp;大端模式"></a>小端模式&amp;大端模式</h3><p>举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：</p>
<p><strong>1)大端模式：</strong></p>
<p>低地址 —————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78</p>
<p><strong>2)小端模式：</strong></p>
<p>低地址 ——————&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12</p>
<p><strong><em>iOS是小端模式</em></strong></p>
<p><a href="https://blog.csdn.net/holyjoy/article/details/37763467" target="_blank" rel="external">大端模式和小端模式</a>起源很有意思。</p>
<h3 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h3><p>⚠️OC对象最少占用16个字节</p>
<p>操作系统在分配内存时也会做对齐（iOS 在分配内存时16个字节的倍数，16，32，64…..256）</p>
<p>iOS对齐系数16字节</p>
<p><a href="https://www.zhihu.com/question/27862634" target="_blank" rel="external">如何理解 struct 的内存对齐？</a></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Designated Initializer For Objective-C]]></title>
      <url>/2018/03/16/Designated-Initializer-For-Objective-C/</url>
      <content type="html"><![CDATA[<p>在阅读 <code>AFNetworking</code> 源码时，发现每个类都有一个初始化方法，都有跟着一个 <code>NS_DESIGNATED_INITIALIZER</code> 宏。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> Initializes an instance of a network reachability manager from the specified reachability object.</div><div class="line"></div><div class="line"> @param reachability The reachability object to monitor.</div><div class="line"></div><div class="line"> @return An initialized network reachability manager, actively monitoring the specified reachability.</div><div class="line"> */</div><div class="line">- (<span class="keyword">instancetype</span>)initWithReachability:(<span class="built_in">SCNetworkReachabilityRef</span>)reachability <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></td></tr></table></figure>
<p>接着发现 <code>NSObject</code>、<code>UIView</code>、<code>UIViewController</code> 也都有，才发现自己之前缺少对源码的留意，格物致知，于是决定一探究竟。</p>
<a id="more"></a>
<h2 id="NS-DESIGNATED-INITIALIZER"><a href="#NS-DESIGNATED-INITIALIZER" class="headerlink" title="NS_DESIGNATED_INITIALIZER"></a>NS_DESIGNATED_INITIALIZER</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef NS_DESIGNATED_INITIALIZER</span></div><div class="line"><span class="meta">#if __has_attribute(objc_designated_initializer)</span></div><div class="line"><span class="meta">#define NS_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))</span></div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="meta">#define NS_DESIGNATED_INITIALIZER</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p><code>NS_DESIGNATED_INITIALIZER</code> 的宏定义中<code>__has_attribute是Clang</code> 的一个用于检测当前编译器是否支持某一特性的一个宏，对你没有听错，<code>__has_attribute</code> 也是一个宏。详细信息见: <a href="http://clang.llvm.org/docs/AttributeReference.html#type-safety-checking" target="_blank" rel="external">Type Safety Checking</a></p>
<p>通过上面的定义，我们可以看到<code>NS_DESIGNATED_INITIALIZER</code>其实是给初始化方法声明的后面加上了一个编译器可见的标记，不要小看这个标记，他可以在编译时就帮我们找出一些潜在的问题。</p>
<p>通过它可以让我们充分发挥编译器的特性（编译时检查，语法错误后并给出<code>warning</code>），进而帮我们找出初始化过程中可能存在的漏洞，增加代码的健壮性，写出更规范的代码。</p>
<h3 id="NSObject-中的-NS-DESIGNATED-INITIALIZER"><a href="#NSObject-中的-NS-DESIGNATED-INITIALIZER" class="headerlink" title="NSObject 中的 NS_DESIGNATED_INITIALIZER"></a>NSObject 中的 NS_DESIGNATED_INITIALIZER</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line"><span class="meta">#if NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER</span></div><div class="line">    <span class="built_in">NS_DESIGNATED_INITIALIZER</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">    ;</div></pre></td></tr></table></figure>
<p>可以看出，如果子类没有指定 <code>NS_DESIGNATED_INITIALIZER</code>，则默认把<code>init</code>方法作为<code>NS_DESIGNATED_INITIALIZER</code>，如果子类有<code>NS_DESIGNATED_INITIALIZER</code>，那么<code>init</code>将只是一个普通的初始化方法。从<code>Objective-C</code>的继承链我们可以看出，除了如<code>NSProxy</code>之外的类，几乎都是派生自<code>NSObject</code>，所有<code>init</code>才成为了所有类的标配初始化方法。</p>
<h3 id="AFNetworkReachabilityManager-中的-NS-DESIGNATED-INITIALIZER"><a href="#AFNetworkReachabilityManager-中的-NS-DESIGNATED-INITIALIZER" class="headerlink" title="AFNetworkReachabilityManager 中的 NS_DESIGNATED_INITIALIZER"></a>AFNetworkReachabilityManager 中的 NS_DESIGNATED_INITIALIZER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// AFNetworkReachabilityManager.h</div><div class="line">// 提供了三个构造方法</div><div class="line"></div><div class="line">+ (instancetype)managerForDomain:(NSString *)domain;</div><div class="line">+ (instancetype)managerForAddress:(const void *)address;</div><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AFNetworkReachabilityManager.m</span></div><div class="line"><span class="comment">// 构造方法的具体实现</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithReachability:(<span class="built_in">SCNetworkReachabilityRef</span>)reachability &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.networkReachability = <span class="built_in">CFBridgingRelease</span>(reachability);</div><div class="line">    <span class="keyword">self</span>.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#ifndef __clang_analyzer__</span></div><div class="line">+ (<span class="keyword">instancetype</span>)managerForDomain:(<span class="built_in">NSString</span> *)domain &#123;</div><div class="line">    <span class="built_in">SCNetworkReachabilityRef</span> reachability = <span class="built_in">SCNetworkReachabilityCreateWithName</span>(kCFAllocatorDefault, [domain UTF8String]);</div><div class="line"></div><div class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> manager;</div><div class="line">&#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="meta">#ifndef __clang_analyzer__</span></div><div class="line">+ (<span class="keyword">instancetype</span>)managerForAddress:(<span class="keyword">const</span> <span class="keyword">void</span> *)address &#123;</div><div class="line">    <span class="built_in">SCNetworkReachabilityRef</span> reachability = <span class="built_in">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)address);</div><div class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> manager;</div><div class="line">&#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>可以看出<code>-(instancetype)managerForDomain:</code> 和 <code>-(instancetype)managerForAddress:</code> 中都调用了 <code>-(instancetype)initWithReachability:</code> 来做初始化。</p>
<p>而 <code>AFNetworkReachabilityManager</code> 是继承与 <code>NSObject</code> 的，那么父类的 <code>-init</code> 将不会成为指定初始化方法。这里还把 <code>-init</code> 方法设置成 <code>NS_UNAVAILABLE</code> ，调用者在 <code>-init</code> 方法时编译器会直接抛出 <code>waring</code> ，从而起到限制的的作用。</p>
<h2 id="开发者文档中的描述"><a href="#开发者文档中的描述" class="headerlink" title="开发者文档中的描述"></a>开发者文档中的描述</h2><blockquote>
<p>In Objective-C, object initialization is based on the notion of a <em>designated initializer</em>, an initializer method that is responsible for calling one of its superclass’s initializers and then initializing its own instance variables. Initializers that are not designated initializers are known as <em>convenience initializers</em>. Convenience initializers typically delegate to another initializer—eventually terminating the chain at a designated initializer—rather than performing initialization themselves.</p>
<p>The designated initializer pattern helps ensure that inherited initializers properly initialize all instance variables. A subclass that needs to perform nontrivial initialization should override all of its superclass’s designated initializers, but it does not need to override the convenience initializers. For more information about initializers, see <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Initialization/Initialization.html#//apple_ref/doc/uid/TP40010810-CH6" target="_blank" rel="external">Object Initialization</a>.</p>
<p>To clarify the distinction between designated and designated initializers clear, you can add the <code>NS_DESIGNATED_INITIALIZER</code> macro to any method in the <code>init</code> family, denoting it a designated initializer. Using this macro introduces a few restrictions:</p>
<ul>
<li>The implementation of a designated initializer must chain to a superclass <code>init</code> method (with <code>[super init...]</code>) that is a designated initializer for the superclass.</li>
<li>The implementation of a convenience initializer (an initializer not marked as a designated initializer within a class that has at least one initializer marked as a designated initializer) must delegate to another initializer (with <code>[self init...]</code>).</li>
<li>If a class provides one or more designated initializers, it must implement all of the designated initializers of its superclass.</li>
</ul>
<p>If any of these restrictions are violated, you receive warnings from the compiler.</p>
<p>If you use the <code>NS_DESIGNATED_INITIALIZER</code> macro in your class, you need to mark all of your designated initializers with this macro. All other initializers will be considered to be convenience initializers.</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fpenxodkptj211v0i0tau.jpg" alt="Multiple initializers"></p>
<h2 id="NS-DESIGNATED-INITIALIZER-使用方法"><a href="#NS-DESIGNATED-INITIALIZER-使用方法" class="headerlink" title="NS_DESIGNATED_INITIALIZER 使用方法"></a>NS_DESIGNATED_INITIALIZER 使用方法</h2><p>关于指定构造器和便利构造器可以看<a href="https://www.2cto.com/kf/201603/491713.html" target="_blank" rel="external">这篇文章</a>,构造器也就是文中的方法。</p>
<p>NS_DESIGNATED_INITIALIZER 使用方法：</p>
<ul>
<li>子类如果有指定初始化方法，那么指定初始化方法实现时必须调用它的直接父类的指定初始化方法。</li>
<li>如果子类有指定初始化方法，那么便利初始化方法必须调用<strong>自己</strong>的其它初始化方法(包括指定初始化方法以及其他的便利初始化方法)，不能调用 <code>super</code> 的初始化方法。</li>
<li>如果子类提供了指定初始化方法，那么一定要实现所有父类的指定初始化方法。</li>
</ul>
<p>如果不遵守以上几条，编译器将会报 <code>warning</code>，由此可以规范化初始化方法，确保子类是调用的父类指定初始化方法，且不会出现循环的调用。</p>
<p><img src="https://ws1.sinaimg.cn/large/8258d55bgy1fpepjroqa1j20cc0bd74t.jpg" alt=""></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Apple 开发者文档： <a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150-CH1-SW8" target="_blank" rel="external">Object Initialization</a>, <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MultipleInitializers.html" target="_blank" rel="external">Multiple initializers</a></p>
<p><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/smileEvday/p/designated_initializer.html" target="_blank" rel="external">iOS: 聊聊 Designated Initializer（指定初始化函数）</a></p>
<p><a href="https://link.jianshu.com/?t=http://blog.jobbole.com/65762/" target="_blank" rel="external">正确编写Designated Initializer的几个原则</a></p>
]]></content>
      
        <categories>
            
            <category> Initializer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocoapods系列（二）公有篇]]></title>
      <url>/2018/03/15/Cocoapods%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%AC%E6%9C%89%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>根据存放代码的仓库不同，对于公开给所有人的开源称为公有库，而对于公司内的开源称为私有库，本文将详细描述如何在GitHub上利用CocoaPods开源公有代码库。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>需要在GitHub上创建一个Public仓库，常规操作不再过多描述，需要注意的是需要在Add a license中选择MIT License（软件授权条款）。</p>
<p>将创建完的仓库clone到工作目录，使用命令行工具创建一个podspec文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec create 库名</div></pre></td></tr></table></figure>
<p>这个文件是告诉<code>Cocoapods</code>你这个库的一些基本信息，包括你的版本号、获取的地址、那些文件是希望被包含进来的等一些信息。</p>
<a id="more"></a>
<p>编辑 podspec文件，这里是用vim打开的，命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim 库名.podspec</div></pre></td></tr></table></figure>
<p>创建之后会自动生成一个模板，里面会有详细的注释，我们只需要按需要修改这个文件即可，下边这个是测试的时候我编辑的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  These will help people to find your library, and whilst it</div><div class="line">  #  can feel like a chore to fill in it&apos;s definitely to your advantage. The</div><div class="line">  #  summary should be tweet-length, and the description more in depth.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.name         = &quot;RYJBlankDataSet&quot;</div><div class="line">  s.version      = &quot;0.0.2&quot;</div><div class="line">  s.summary      = &quot;Easy to make blank page.&quot;</div><div class="line"></div><div class="line">  # This description is used to generate tags and improve search results.</div><div class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</div><div class="line">  #   * Try to keep it short, snappy and to the point.</div><div class="line">  #   * Write the description between the DESC delimiters below.</div><div class="line">  #   * Finally, don&apos;t worry about the indent, CocoaPods strips it!</div><div class="line">  s.description  = &quot;Make blank page implementation simpler and more flexible.&quot;</div><div class="line"></div><div class="line">  s.homepage     = &quot;https://github.com/developRen/RYJBlankDataSet&quot;</div><div class="line">  # s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot;</div><div class="line"></div><div class="line"></div><div class="line">  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  Licensing your code is important. See http://choosealicense.com for more info.</div><div class="line">  #  CocoaPods will detect a license file if there is a named LICENSE*</div><div class="line">  #  Popular ones are &apos;MIT&apos;, &apos;BSD&apos; and &apos;Apache License, Version 2.0&apos;.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.license      = &quot;MIT&quot;</div><div class="line">  # s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line"></div><div class="line"></div><div class="line">  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  Specify the authors of the library, with email addresses. Email addresses</div><div class="line">  #  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</div><div class="line">  #  accepts just a name if you&apos;d rather not provide an email address.</div><div class="line">  #</div><div class="line">  #  Specify a social_media_url where others can refer to, for example a twitter</div><div class="line">  #  profile URL.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.author             = &#123; &quot;YiJie Ren&quot; =&gt; &quot;jie_ios@163.com&quot; &#125;</div><div class="line">  # Or just: s.author    = &quot;RYJ&quot;</div><div class="line">  # s.authors            = &#123; &quot;RYJ&quot; =&gt; &quot;&quot; &#125;</div><div class="line">  # s.social_media_url   = &quot;http://twitter.com/RYJ&quot;</div><div class="line"></div><div class="line">  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  If this Pod runs only on iOS or OS X, then specify the platform and</div><div class="line">  #  the deployment target. You can optionally include the target after the platform.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.platform     = :ios, &quot;8.0&quot;</div><div class="line">  # s.platform     = :ios, &quot;5.0&quot;</div><div class="line"></div><div class="line">  #  When using multiple platforms</div><div class="line">  # s.ios.deployment_target = &quot;5.0&quot;</div><div class="line">  # s.osx.deployment_target = &quot;10.7&quot;</div><div class="line">  # s.watchos.deployment_target = &quot;2.0&quot;</div><div class="line">  # s.tvos.deployment_target = &quot;9.0&quot;</div><div class="line"></div><div class="line"></div><div class="line">  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  Specify the location from where the source should be retrieved.</div><div class="line">  #  Supports git, hg, bzr, svn and HTTP.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/developRen/RYJBlankDataSet&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class="line"></div><div class="line"></div><div class="line">  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  CocoaPods is smart about how it includes source code. For source files</div><div class="line">  #  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</div><div class="line">  #  For header files it will include any header in the folder.</div><div class="line">  #  Not including the public_header_files will make all headers public.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.source_files  = &quot;RYJBlankView/RYJBlankDataSet&quot;, &quot;RYJBlankView/RYJBlankDataSet/**/*.&#123;h,m&#125;&quot;</div><div class="line">  s.exclude_files = &quot;Classes/Exclude&quot;</div><div class="line"></div><div class="line">  # s.public_header_files = &quot;Classes/**/*.h&quot;</div><div class="line"></div><div class="line"></div><div class="line">  # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  A list of resources included with the Pod. These are copied into the</div><div class="line">  #  target bundle with a build phase script. Anything else will be cleaned.</div><div class="line">  #  You can preserve files from being cleaned, please don&apos;t preserve</div><div class="line">  #  non-essential files like tests, examples and documentation.</div><div class="line">  #</div><div class="line"></div><div class="line">  # s.resource  = &quot;icon.png&quot;</div><div class="line">  # s.resources = &quot;Resources/*.png&quot;</div><div class="line"></div><div class="line">  # s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;</div><div class="line"></div><div class="line"></div><div class="line">  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  Link your library with frameworks, or libraries. Libraries do not include</div><div class="line">  #  the lib prefix of their name.</div><div class="line">  #</div><div class="line"></div><div class="line">  s.framework  = &quot;UIKit&quot;</div><div class="line">  # s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</div><div class="line"></div><div class="line">  # s.library   = &quot;iconv&quot;</div><div class="line">  # s.libraries = &quot;iconv&quot;, &quot;xml2&quot;</div><div class="line"></div><div class="line"></div><div class="line">  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</div><div class="line">  #</div><div class="line">  #  If your library depends on compiler flags you can set them in the xcconfig hash</div><div class="line">  #  where they will only apply to your library. If you depend on other Podspecs</div><div class="line">  #  you can include multiple dependencies to ensure it works.</div><div class="line"></div><div class="line">  # s.requires_arc = true</div><div class="line"></div><div class="line">  # s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;</div><div class="line">  # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="发布公有库"><a href="#发布公有库" class="headerlink" title="发布公有库"></a>发布公有库</h2><p>创建tag，并推送到github,依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git commit -m &quot;描述&quot;</div><div class="line">$ git tag -a &apos;版本号&apos; -m &apos;描述&apos;</div><div class="line">$ git push --tags</div><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>验证podspec文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec lint 库名.podspec</div></pre></td></tr></table></figure>
<p>如果验证不通过，会有详细的ERROR和WARING提示，根据提示依次解决，然后重新来一遍。<br><strong>注意：</strong>在重新开始之前，我们要删除远程库的tag和本地的tag，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -d 版本号                  // 删除本地tag</div><div class="line">$ git push origin :refs/tags/版本号  // 删除远程库tag</div></pre></td></tr></table></figure>
<p>验证通过后，提交到CocoaPods。命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod trunk push 库名.podspec</div></pre></td></tr></table></figure>
<p>如果是第一次提交，需要先执行这个命令，邮箱验证通过后再提交到CocoaPods：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod trunk register 这里写邮箱 &apos;这里起个名字&apos; --description=&apos; 这里写描述&apos;</div></pre></td></tr></table></figure>
<h2 id="使用公有库"><a href="#使用公有库" class="headerlink" title="使用公有库"></a>使用公有库</h2><p>提交完成后，就可以通过cocopods查找该公有库了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod search 库名</div></pre></td></tr></table></figure>
<p>具体使用可以看作者前一篇文章<a href="http://renyijie.top/2018/02/03/Cocoapods系列（一）使用篇/" target="_blank" rel="external">Cocoapods系列（一）使用篇</a></p>
<h2 id="迭代更新公有库"><a href="#迭代更新公有库" class="headerlink" title="迭代更新公有库"></a>迭代更新公有库</h2><p>首先更新 pod 中的文件, 及 podspec, 在示例程序中无错误后, podspec 中的 version 改为更大的版本号。操作 git:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git commit -m '描述'</div><div class="line">$ git push</div><div class="line">$ git tag -a '版本号' -m '描述'</div><div class="line">$ git push --tags</div><div class="line">$ pod trunk push 库名.podspec</div></pre></td></tr></table></figure>
<p>再将 podspec 利用上面 repo push 命令推到私有源, podfile 修改对应版本号, pod update 对应pod, 完成了版本的升级. 值得注意的是 git 的 tag 不要删除, 否则会出现一些缓存问题.</p>
]]></content>
      
        <categories>
            
            <category> 工具集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cocoapods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocoapods系列（一）使用篇]]></title>
      <url>/2018/02/03/Cocoapods%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>对于做iOS开发的绝大多数开发者而言，<code>Cocoapods</code> 并不陌生。无论是日常开发，还是编写 <code>Dome</code>，时常用到 <code>Cocoapods</code> 来管理库文件的依赖。</p>
<p>笔者之前也只是停留在用 <code>Cocoapods</code> 导入第三方库而已，由于对于组件化学习的深入和发布自己的代码库的需求，于是有了该系列的文章，来梳理 <code>Cocoapods</code> 使用过程中的一些细节。</p>
<p>网络上也有大量关于 <code>Cocoapods</code> 安装、替换镜像的文章，在此也不再累赘描述。</p>
<p>本文将会着重讲解<code>Podfile文件</code>以及<code>pod命令行</code>。</p>
<blockquote>
<p>关于<a href="http://renyijie.top/2017/07/09/CocoaPod工作原理/" target="_blank" rel="external">Cocoapods的工作原理</a>可见笔者另一篇博文。</p>
</blockquote>
<a id="more"></a>
<h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><p>就比如我们最常用的<code>AFNetworking</code>来说的话，只需在<code>项目名.xcodeproj</code>的目录下创建一个<code>Podfile</code>的文件，然后打开文件，填入一下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">target 'target name' do</div><div class="line">use_frameworks!</div><div class="line">pod 'AFNetworking'</div><div class="line">end</div></pre></td></tr></table></figure>
<p>然后保存，并且打开一个命令行，跳转到<code>Podfile</code>的目录直接运行<code>pod install</code>即可。 当然，你会看到你的目录下回多了目录<code>Pods</code>, 文件<code>Podfile.lock</code>以及文件<code>项目名.xcworkspace</code>。以后你打开项目就再也不是<code>xcodeproj</code>的文件了，而是<code>wxcworkspcace</code>的文件。然后你打开项目就会看到除了你的项目外，下面多了一个<code>Pods</code>的一个项目。</p>
<p>就此，对于你项目需要依赖的<code>AFNetworking</code>的依赖了。非常简单对吧？ 如果你只是想简单的使用<code>Cocoapods</code>,估计到这一步就完全够了。</p>
<h2 id="Podfile-lock文件"><a href="#Podfile-lock文件" class="headerlink" title="Podfile.lock文件"></a>Podfile.lock文件</h2><p>在执行完<code>pod install</code>之后，会生成一个<code>Podfile.lock</code>文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。</p>
<p>该文件用于保存已经安装的<code>Pods</code>依赖库的版本，通过<code>CocoaPods</code>安装了<code>AFNetworking</code>依赖库以后对应的<code>Podfile.lock</code>文件内容为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">PODS:</div><div class="line">  - AFNetworking (<span class="number">3.1</span><span class="number">.0</span>):</div><div class="line">    - AFNetworking/<span class="built_in">NSURLSession</span> (= <span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">    - AFNetworking/Reachability (= <span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">    - AFNetworking/Security (= <span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">    - AFNetworking/Serialization (= <span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">    - AFNetworking/<span class="built_in">UIKit</span> (= <span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">  - AFNetworking/<span class="built_in">NSURLSession</span> (<span class="number">3.1</span><span class="number">.0</span>):</div><div class="line">    - AFNetworking/Reachability</div><div class="line">    - AFNetworking/Security</div><div class="line">    - AFNetworking/Serialization</div><div class="line">  - AFNetworking/Reachability (<span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">  - AFNetworking/Security (<span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">  - AFNetworking/Serialization (<span class="number">3.1</span><span class="number">.0</span>)</div><div class="line">  - AFNetworking/<span class="built_in">UIKit</span> (<span class="number">3.1</span><span class="number">.0</span>):</div><div class="line">    - AFNetworking/<span class="built_in">NSURLSession</span></div><div class="line"></div><div class="line">DEPENDENCIES:</div><div class="line">  - AFNetworking</div><div class="line"></div><div class="line">SPEC CHECKSUMS:</div><div class="line">  AFNetworking: <span class="number">5e0</span>e199f73d8626b11e79750991f5d173d1f8b67</div><div class="line"></div><div class="line">PODFILE CHECKSUM: <span class="number">023</span>cc304232df5f2f4cbc2ab8d90949d95b41a34</div><div class="line"></div><div class="line">COCOAPODS: <span class="number">1.3</span><span class="number">.1</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>Podfile.lock</code>文件最大得用处在于多人开发。</p>
</blockquote>
<p>对于没有在<code>Podfile文件</code>中指定<code>Pods</code>依赖库版本的写法，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod 'AFNetworking'</div></pre></td></tr></table></figure>
<p>该句话用于获取当前<code>AFNetworking</code>这个<code>Pods</code>依赖库的最新版本。</p>
<p>当团队中的某个人执行完<code>pod install</code>命令后，生成的<code>Podfile.lock文件</code>就记录下了当时最新<code>Pods</code>依赖库的版本，这时团队中的其它人从<code>Git</code>拉取下来这份包含<code>Podfile.lock文件</code>的工程以后，再去执行pod install命令时，获取下来的<code>Pods</code>依赖库的版本就和最开始用户获取到的版本一致。如果没有<code>Podfile.lock</code>文件，后续所有用户执行<code>pod install</code>命令都会获取最新版本的<code>AFNetworking</code>，这就有可能造成同一个团队使用的依赖库版本不一致。</p>
<blockquote>
<p>这对团队协作来说绝对是个灾难！</p>
</blockquote>
<p>但是当执行<code>pod update</code>命令时，将会忽略<code>Podfile.lock文件</code>把<code>AFNetworking</code>更新至最新版本，那么仍有可能导致同一个团队使用的依赖库版本不一致。</p>
<p>若是既想保持依赖库保持最新版本，又想团队中依赖库版本保持一致，在这种情况下，笔者认为最优的方案：</p>
<ul>
<li>更改<code>Podfile文件</code>，使其指向最新版本的<code>AFNetworking</code>依赖库<code>pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;</code>;</li>
<li>执行<code>pod update</code>命令；</li>
</ul>
<h2 id="Podfile文件"><a href="#Podfile文件" class="headerlink" title="Podfile文件"></a>Podfile文件</h2><h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>首先先来讲讲最核心的<code>pod</code>关键字吧。关于pod的使用在上面可以看得出来是<code>pod &#39;框架名&#39; 参数</code>。 当然对于前面两个<code>pod &#39;框架名&#39;</code>是固定的，没上面好说，参数的话，这里主要讲参数。</p>
<h4 id="参数一：-版本号"><a href="#参数一：-版本号" class="headerlink" title="参数一： 版本号"></a>参数一： 版本号</h4><p>版本号可以是大于、小于、等于等。当然具体的可以是’&gt; 3.7’, ‘&gt;= 3.7’, ‘&lt; 3.7’, ‘3.7’以及’~&gt; 3.7’。关于普通的就没什么好说了，最后一个<code>~&gt;</code>指的是正对最后一位来说。如使用’~&gt; 3.7.4’,意味着’&gt;= 3.7.4’并且’&lt; 3.8.0’的意思。</p>
<h4 id="参数二：地址"><a href="#参数二：地址" class="headerlink" title="参数二：地址"></a>参数二：地址</h4><p><code>Cocoapods</code>可以指定某一个git的目录或者是本地的目录。有的时候我们希望一直用某一个版本最新的版本，即使没有打版本的话，我们可以直接后面接上:<code>git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;</code>。 </p>
<p>当然除了这种情况外，还有可能是如果是我们自己开发的私有库，并且在开发阶段的情况下，可能就希望开发模式进行引用，则可以使用path参数：<code>:path =&gt; &#39;~/Documents/AFNetworking&#39;</code>。</p>
<blockquote>
<p>具体使用可见笔者Cocoapods系列另一篇博文<a href="">《Cocoapods系列（三）私有篇》</a>。</p>
</blockquote>
<h4 id="参数三：tag、branche、commit"><a href="#参数三：tag、branche、commit" class="headerlink" title="参数三：tag、branche、commit"></a>参数三：tag、branche、commit</h4><p>有的时候我们希望引用有一个<code>tag</code>，<code>branch</code>或者是<code>comit</code>的内容的话可以使用这个参数，分别用<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</p>
<h4 id="参数四：inhibit-warnings-gt-true"><a href="#参数四：inhibit-warnings-gt-true" class="headerlink" title="参数四：inhibit_warnings =&gt; true"></a>参数四：inhibit_warnings =&gt; true</h4><p>对于强迫症患者而言，一个项目中很多<code>warnings</code>是非常难以忍受的。自然这个参数是用来避免那些第三方框架中带来的<code>warnings</code>。用法<code>:inhibit_warnings =&gt; true</code>。</p>
<h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>这个参数是只依赖的库希望在哪个平台被编译。 一句话带过吧,直接使用<code>platform :ios, &#39;9.0&#39;</code>。需要注意的是如果在<code>platform</code>后面没有跟东西的话，默认是在<code>iOS4.3</code>,<code>OSX 10.6</code>,<code>tvOS 9.0</code>以及<code>watchOS 2.0</code>的情况下编译的。很多库都是从6.0或者7.0才开始支持的，肯能会造成编译不通过。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>这个是指定具体的配置是适配在哪个<code>target</code>，这里的<code>target</code>值得就是<code>Xcode</code>中的<code>target</code>。如果对于一些项目中你的不同<code>target</code>引用的框架不同的话，可以采用这个进行区分。</p>
<p>比如创建项目时勾选了<code>Tests</code>和<code>UITests</code>,那么必须声明是那个<code>target</code>导入的依赖库。</p>
<h3 id="use-frameworks"><a href="#use-frameworks" class="headerlink" title="use_frameworks!"></a>use_frameworks!</h3><p>这个指明编译成动态库，而不是静态库。</p>
<p><a href="https://segmentfault.com/a/1190000007076865" target="_blank" rel="external">Podfile中的 use_frameworks!</a>一文中详细的描述了<code>use_frameworks</code>用法。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>这个参数是指<code>Cocoapods</code>从哪些仓库(<code>Spec</code>)中获得框架的源代码，如果在结合使用开源库以及自己私有库的情况下，这个参数还是非常有意义的。博主之前在用到自己私有库的情况下就不懂这点，最后查了好久资料才知道的。只需要在<code>Podfile</code>文件开头列出你需要引用库的所有仓库地址即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source 'https://github.com/artsy/Specs.git'  </div><div class="line">source 'https://192.168.0.90:8888/MySepcs/Specs.git'</div></pre></td></tr></table></figure>
<h3 id="Podfile-Demo"><a href="#Podfile-Demo" class="headerlink" title="Podfile Demo"></a>Podfile Demo</h3><p>对于<code>Podfile</code>常用几个关键字拿出来说了一下，如果还有更深入不懂的情况下，可以查看<a href="https://guides.cocoapods.org/syntax/podfile.html#podfile" target="_blank" rel="external">Cocoapods Guide</a>。 最后给一个官方的<code>Demo</code>吧。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># open source</div><div class="line">source 'https://github.com/CocoaPods/Specs.git'</div><div class="line"></div><div class="line"># my work</div><div class="line">source 'https://github.com/Artsy/Specs.git'</div><div class="line"></div><div class="line">target 'App' do</div><div class="line"></div><div class="line">  pod 'Artsy+UIColors'</div><div class="line">  pod 'Artsy+UIButtons'</div><div class="line"></div><div class="line">  pod 'FLKAutoLayout'</div><div class="line">  pod 'ISO8601DateFormatter', '0.7'</div><div class="line">  pod 'AFNetworking', '~&gt; 2.0'</div><div class="line"></div><div class="line">  target 'AppTests' do</div><div class="line">    pod 'FBSnapshotTestCase'</div><div class="line">    pod 'Quick'</div><div class="line">    pod 'Nimble'</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>在使用<code>Cocoapods</code>的过程中，我们可能要更新或者是安装一个新的第三方框架。自然这里就避免不了要用<code>pod install</code> 和 <code>pod update</code>这两个命令了。</p>
<p>对于这两个命令来说，一个是在有新的第三方框架引入是运行，另一个是纯粹为了更新本地的第三框架。 对于二者的命令来说其参数都是大同小异的，这里大概讲解一下。</p>
<h3 id="参数–no-repo-update"><a href="#参数–no-repo-update" class="headerlink" title="参数–no-repo-update"></a>参数–no-repo-update</h3><p>这个参数应该是大家最常用的参数之一，其主要的作用是用于在执行<code>pod install</code>和<code>pod update</code>两条命令是而执行的<code>pod repo update</code>的操作。而<code>pod repo update</code>则是跟新本地已有的第三框框架。对于大多数情况下，我们只希望跟新当前项目的，并且这个操作执行的时间都是相对比较长，所以在执行这两条命令是，大多数人都添加了这个参数。</p>
<h3 id="参数–verbose-和-–silent"><a href="#参数–verbose-和-–silent" class="headerlink" title="参数–verbose 和 –silent"></a>参数–verbose 和 –silent</h3><p>这两个参数是用来控制<code>pod</code>命令的,而有些人不希望看到输出的情况下可以选择<code>--silent</code>。而对于在执行这两条命令的情况下如果出错了，则可能添加<code>--verbose</code>的参数能看到具体的出错信息。<code>--verbose</code>则是用来输出这两条命令执行过程中所包含的所有信息。对于大多数的<code>Cocoapods</code>的命令行来说都带有着两个参数。</p>
<p>其他的细节就不具体说了，大家可以通过<code>help</code>命令来进行查看详情。</p>
<h3 id="常用命令行集合"><a href="#常用命令行集合" class="headerlink" title="常用命令行集合"></a>常用命令行集合</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  创建默认的 Podfile  </span></div><div class="line">$ pod init  </div><div class="line">      </div><div class="line"><span class="comment">//  第一次使用安装框架  </span></div><div class="line">$ pod install  </div><div class="line">      </div><div class="line"><span class="comment">//  安装框架，不更新本地索引，速度快  </span></div><div class="line">$ pod install --no-repo-update  </div><div class="line">         </div><div class="line"><span class="comment">//  今后升级、添加、删除框架，或者框架不好用都使用这个命令  </span></div><div class="line">$ pod update  </div><div class="line">      </div><div class="line"><span class="comment">//  更新框架，不更新本地索引，速度快  </span></div><div class="line">$ pod update --no-repo-update  </div><div class="line">      </div><div class="line"><span class="comment">//  搜索框架  </span></div><div class="line">$ pod search XXX  </div><div class="line">      </div><div class="line"><span class="comment">//  帮助  </span></div><div class="line">$ pod --help </div><div class="line">    </div><div class="line">终端命令: control + C 取消上一次操作;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说要使用<code>Cocoapods</code>只需通过三个步骤：安装、写<code>Podfile</code>和<code>pod install</code>命令即可。</p>
<p>但是对于一个有理想的大好青年来说，绝不会止步于此。</p>
<p>本着为人类伟大的开源主义事业奋斗终身的目标，以及加入热火朝天的组件化开发浪潮的目的。</p>
<p><code>Cocoapods系列</code>后续文章将以这两个目标和目的展开，分享如何在一个项目同时使用私有库和开源库，以及如何进行组件化管理。</p>
]]></content>
      
        <categories>
            
            <category> 工具集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cocoapods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveCocoa Novice Guide]]></title>
      <url>/2018/01/31/ReactiveCocoa-Novice-Guide/</url>
      <content type="html"><![CDATA[<p>看了很多关于ReactiveCocoa的文章，总结成一句：ReactiveCocoa(RAC) 是来拯救我们的。</p>
<h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><p><code>RACSignal</code> (信号)就 RAC 来说是构造单元。它代表我们最终将要收到的信息，当你能将未来某时刻收到的消息具体表示出来时, <strong>你可以开始预先(陈述性)运用逻辑并构建你的信息流,</strong>而不是必须等到事件发生(命令式). </p>
<p><strong>信号会为了控制通过应用的信息流而获得所有这些异步方法(委托, 回调 block, 通知, KVO, target/action 事件观察, 等)并将它们统一到一个接口下.</strong>这只是直观理解. 不仅是这些, 因为信息会流过你的应用, 它还提供给你轻松转换/分解/合并/过滤信息的能力.</p>
<a id="more"></a>
<h2 id="那么什么是信号呢"><a href="#那么什么是信号呢" class="headerlink" title="那么什么是信号呢?"></a>那么什么是信号呢?</h2><p>信号是一个发送一连串值的物体. 但是我们这儿的信号啥也不干, 因为它还没有订阅者. 如果有订阅者监听时(已订阅)信号才会发信息. 它将会向那个订阅者发送0或多个载有数值的”next”事件, 后面跟着一个”complete”事件或一个”error”事件. </p>
<h2 id="信号发送的值是从哪获得的"><a href="#信号发送的值是从哪获得的" class="headerlink" title="信号发送的值是从哪获得的?"></a>信号发送的值是从哪获得的?</h2><p>信号是一些等待某事发生的异步代码, 然后把结果值发送给它们的订阅者. 你可以用 <code>RACSignal</code> 的类方法 <code>createSignal:</code> 手动创建信号: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//networkSignal.m</div><div class="line">RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber)&#123;</div><div class="line">        NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;];</div><div class="line">        [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123;</div><div class="line">            [subscriber sendNext:result];</div><div class="line">            [subscriber sendCompleted];</div><div class="line">        &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123;</div><div class="line">            [subscriber sendError:error];</div><div class="line">        &#125;];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>我在这用一个具有成功和失败 block (伪造)的网络操作创建了一个信号. (如果我想让信号在被订阅时才让网络请求发生, 还可以用 <code>RACSignal</code> 的类方法 <code>defer</code>. )我在成功的 block 里使用提供的 <code>subscriber</code> 对象调用 <code>sendNext:</code> 和 <code>sendCompleted:</code> 方法, 或在失败的 block 中调用 <code>sendError:</code>. 现在我可以订阅这个信号并将在响应返回时接收到 json 值或是 error. </p>
<ul>
<li>next：是可以为nil的新值, RACStream方法只能在这个值上进行操作运算。</li>
<li>error：表示在Signals完成之前发生了错误，值不会在RACStream类中存储。</li>
<li>completed：表示Signals成功的完成，值不会在RACStream类中存储。</li>
</ul>
<p>幸运的是, RAC 的创造者实际上使用它们自己的库来创建真的事物(捉摸一下), 所以对于我们在日常需要什么, 他们有很强烈的想法. 他们为我们提供了很多机制, 来从我们通常使用的现存的异步模式中拉取信号. 别忘了如果你有一个没有被某个内建信号覆盖到的异步任务, 你可以<em>很容易地</em>用 <code>createSignal:</code> 或类似方法来创建信号. </p>
<p>一个被提供的机制就是 <code>RACObserve()</code> 宏. (如果你不喜欢宏, 你可以简单地看看罩子下面并用稍微多些冗杂的描述. 这也非常好. 在我们得到 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/pull/1382" target="_blank" rel="external">Swift 版本的替代</a>之前, 这也有<a href="http://blog.scottlogic.com/2014/07/24/mvvm-reactivecocoa-swift.html" target="_blank" rel="external">在 Swift 中使用 RAC</a> 的解决方案. )这个宏是 RAC 中对 KVO 中那些悲惨的 API 的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后,  <code>RACObserve</code> 会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RACSignal *usernameValidSignal = RACObserve(self.viewModel,  usernameIsValid);</div></pre></td></tr></table></figure>
<p>这仅是提供用于创建信号的一个工具. 这里有几个立即可用的方式, 来从内置控制流机制中拉取信号: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//signals.m</div><div class="line">RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside];</div><div class="line">    // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc)</div><div class="line">    // subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;</div><div class="line"> </div><div class="line">RACSignal *textChange = [myTextField rac_textSignal];</div><div class="line">    // some special methods are provided for commonly needed control event values off certain controls</div><div class="line">    // subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;</div><div class="line"> </div><div class="line">RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal];</div><div class="line">    // signals for some delegate methods send the delegate params as the value</div><div class="line">    // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc</div><div class="line">    // (limited to methods that return void)</div><div class="line">    // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;</div><div class="line"> </div><div class="line">RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)];</div><div class="line">    // signals for arbitrary selectors that return void, send the method params as the value</div><div class="line">    // works for built in or your own methods</div><div class="line">    // subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; &#125;</div></pre></td></tr></table></figure>
<h2 id="什么是订阅者"><a href="#什么是订阅者" class="headerlink" title="什么是订阅者?"></a>什么是订阅者?</h2><p>简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了. (它也可以作用于 “complete” 和 “error” 事件. )</p>
<p>这有一个简单的订阅者, 是通过向信号的实例方法 <code>subscribeNext</code> 传入一个 block 来创建的. 我们在这通过 <code>RACObserve()</code> 宏创建信号来观察一个对象上属性的当前值, 并把它赋值给一个内部属性. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void) viewDidLoad &#123;</div><div class="line">  // . . . </div><div class="line">  // create and get a reference to the signal</div><div class="line">  RACSignal *usernameValidSignal = RACObserve(self.viewModel,  isUsernameValid);</div><div class="line">  // update the local property when this value changes</div><div class="line">  [usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123;</div><div class="line">          self.usernameIsValid = isValidNumber. boolValue</div><div class="line">      &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 RAC 只处理对象, 而不处理像 <code>BOOL</code> 这样的原始值. 不过不用担心, RAC 通常会帮你这些转换. </p>
<p>幸运的是 RAC 的创造者也意识到这种绑定行为的普遍必要性, 所以他们提供了另一个宏 <code>RAC()</code>. 与 <code>RACObserve()</code> 相同, 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值. 我们的例子现在看起来像这样: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void) viewDidLoad &#123;</div><div class="line">    //. . . </div><div class="line">    RAC(self,  usernameIsValid) = RACObserve(self.viewModel,  isUsernameValid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考虑下我们的目标, 这么干有点傻啊. 我们不需要将信号发送的值存到属性中(这会创建状态), 我们真正要做的是用从那个值获取到信息来更新 UI. </p>
<h2 id="转换数据流"><a href="#转换数据流" class="headerlink" title="转换数据流"></a>转换数据流</h2><p>现在我们进入 RAC 为我们提供的用于转换数值流的方法. 我们将会利用 <code>RACSignal</code> 的实例方法 <code>map</code>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//transformingStreams.m</div><div class="line">- (void) viewDidLoad &#123;</div><div class="line">    //...</div><div class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);</div><div class="line">    RAC(self.goButton, enabled) = usernameIsValidSignal;</div><div class="line">    RAC(self.goButton, alpha) = [usernameIsValidSignal</div><div class="line">        map:^id(NSNumber *usernameIsValid) &#123;</div><div class="line">            return usernameIsValid.boolValue ? @1.0 : @0.5;</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样现在我们将 view-model 上的 <code>isUsernameValid</code> 发生的变化直接绑定到 <code>goButton</code> 的 <code>enabled</code> 属性上. 酷吧?对 <code>alpha</code>的绑定更酷, 因为我们正在使用 <code>map</code> 方法将值转换成与 <code>alpha</code> 属性相关的值. (注意在这里我们返回的是一个 <code>NSNumber</code> 对象而不是原始float值. 这基本上是唯一的污点: 你需要负责为 RAC 将原始值转化为对象, 因为它不能帮你导出来.</p>
<h2 id="RAC常用宏"><a href="#RAC常用宏" class="headerlink" title="RAC常用宏"></a>RAC常用宏</h2><h3 id="RACObserve-TARGET-KEYPATH"><a href="#RACObserve-TARGET-KEYPATH" class="headerlink" title="RACObserve(TARGET, KEYPATH)"></a>RACObserve(TARGET, KEYPATH)</h3><p>表现形式:RACObserve(self, stringProperty)</p>
<p>KVO的简化版本 相当于对TARGET中KEYPATH的值设置监听，返回一个RACSignal</p>
<h3 id="RAC-TARGET-…"><a href="#RAC-TARGET-…" class="headerlink" title="RAC(TARGET, …)"></a>RAC(TARGET, …)</h3><p>表现形式:RAC(self, stringProperty)  = TextField.rac_textSignal</p>
<p>第一个是需要设置属性值的对象，第二个是属性名</p>
<p>RAC宏允许直接把信号的输出应用到对象的属性上</p>
<p>每次信号产生一个next事件，传递过来的值都会应用到该属性上</p>
<h3 id="RACChannelTo-TARGET-…"><a href="#RACChannelTo-TARGET-…" class="headerlink" title="RACChannelTo(TARGET, …)"></a>RACChannelTo(TARGET, …)</h3><p>RACChannelTo 用于双向绑定</p>
<p>RACChannelTo(self, stringProperty)=RACChannelTo(self.label, text) ;</p>
<p><a href="http://blog.csdn.net/sodaslay/article/details/72794114" target="_blank" rel="external">RAC 双向绑定实现案例</a></p>
<h2 id="RAC基础使用"><a href="#RAC基础使用" class="headerlink" title="RAC基础使用"></a>RAC基础使用</h2><h3 id="subscribeNext"><a href="#subscribeNext" class="headerlink" title="subscribeNext"></a>subscribeNext</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self.usernameTextField.rac_textSignal </div><div class="line">    subscribeNext:^(id x)&#123;    // 设置订阅 监听TextField</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>过滤器,可以添加一些筛选条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self.usernameTextField.rac_textSignal</div><div class="line">    filter:^BOOL(NSString* text)&#123;</div><div class="line">    return text.length &gt; 3;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>使用map可以对信号进行转换，一个源信号转换成另外一个新的信号输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[[self.usernameTextField.rac_textSignal</div><div class="line">map:^id(NSString*text)&#123;</div><div class="line">  return @(text.length);</div><div class="line">&#125;]</div><div class="line">filter:^BOOL(NSNumber*length)&#123;</div><div class="line">  return[length integerValue] &gt; 3;</div><div class="line">&#125;]</div><div class="line">subscribeNext:^(id x)&#123;</div><div class="line">  NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="聚合-combineLatest-reduce"><a href="#聚合-combineLatest-reduce" class="headerlink" title="聚合(combineLatest: reduce:)"></a>聚合(combineLatest: reduce:)</h3><p>多个信号可以聚合成一个新的信号，这个可以是任何类型的信号.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RAC(self.loginButton, enabled) = [RACSignal combineLatest:@[self.userNameFeild.rac_textSignal,                                                                         														  self.passwordFeild.rac_textSignal]</div><div class="line">                                                                reduce:^(NSString *username, 																	   NSString *password) &#123;</div><div class="line">                                                                    return @0;</div><div class="line">                                                                &#125;];</div></pre></td></tr></table></figure>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>一个信号可以有很多subscriber，也就是作为很多后续步骤的源.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = self.usernameTextField.rac_textSignal;</div><div class="line">[signal subscribeNext:^(id x) &#123;</div><div class="line">	NSLog(@&quot;1111&quot;);</div><div class="line">&#125;];</div><div class="line">[signal subscribeNext:^(id x) &#123;</div><div class="line">	NSLog(@&quot;2222&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="Button的ControlEvents"><a href="#Button的ControlEvents" class="headerlink" title="Button的ControlEvents"></a>Button的ControlEvents</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[self.signInButton</div><div class="line">     rac_signalForControlEvents:UIControlEventTouchUpInside]</div><div class="line">     subscribeNext:^(id x) &#123;</div><div class="line">     NSLog(@&quot;button click&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="doNext"><a href="#doNext" class="headerlink" title="doNext"></a>doNext</h3><p>为一个附加操作，在一个next事件发生时执行的逻辑，而该逻辑并不改变事件本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[_login rac_signalForControlEvents:UIControlEventTouchUpInside] </div><div class="line">	doNext:^(id x) &#123;</div><div class="line">	// 点击按钮时执行其他逻辑</div><div class="line">    &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<h3 id="flattenMap"><a href="#flattenMap" class="headerlink" title="flattenMap"></a>flattenMap</h3><p><a href="http://blog.csdn.net/abc649395594/article/details/46552865" target="_blank" rel="external">信号的FlattenMap与Map</a></p>
<h2 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h2><p>在ReactiveCocoa中提供了避免循环引用的方法</p>
<ul>
<li>@weakify宏让你创建一个弱引用的影子对象（如果你需要多个弱引用，你可以传入多个变量），</li>
<li>@strongify让你创建一个对之前传入@weakify对象的强引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@weakify(self) </div><div class="line">[[self.searchText.rac_textSignal </div><div class="line">map:^id(NSString *text) &#123; </div><div class="line">    return [self isValidSearchText:text] ? </div><div class="line">        [UIColor whiteColor] : [UIColor yellowColor]; </div><div class="line">&#125;] </div><div class="line">subscribeNext:^(UIColor *color) &#123; </div><div class="line">    @strongify(self) </div><div class="line">    self.searchText.backgroundColor = color; </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="RAC使用场景"><a href="#RAC使用场景" class="headerlink" title="RAC使用场景"></a>RAC使用场景</h2><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>待续</p>
<h3 id="实时搜索内容方法"><a href="#实时搜索内容方法" class="headerlink" title="实时搜索内容方法"></a>实时搜索内容方法</h3><p>待续</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>待续</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/abc649395594/article/details/45933053" target="_blank" rel="external">ReactiveCocoa框架菜鸟入门</a></p>
<p><a href="https://www.jianshu.com/p/e99cb4310482" target="_blank" rel="external">ReactiveCocoa(RAC)－iOS</a></p>
<p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.cocoachina.com%2Findustry%2F20140115%2F7702.html" target="_blank" rel="external">说说ReactiveCocoa 2</a></p>
<p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fcbsfly.github.io%2Fios%2Frac1" target="_blank" rel="external">学习RAC小记-适合给新手看的RAC用法总结</a></p>
<p><a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.raywenderlich.com%2F62699%2Freactivecocoa-tutorial-pt1" target="_blank" rel="external">ReactiveCocoa-tutorial-pt1</a></p>
<p><a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.raywenderlich.com%2F62796%2Freactivecocoa-tutorial-pt2" target="_blank" rel="external">ReactiveCocoa-tutorial-pt2</a></p>
<p><a href="https://link.jianshu.com/?t=http%3A%2F%2Ftwocentstudios.com%2F2014%2F06%2F08%2Fon-mvvm-and-architecture-questions%2F" target="_blank" rel="external">MVVC-RAC</a></p>
<p><a href="https://www.jianshu.com/p/fd407a4ecb8e" target="_blank" rel="external">iOS 基于MVVM + RAC + ViewModel-Based Navigation的微信开发（一）</a></p>
]]></content>
      
        <categories>
            
            <category> Objective-C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RAC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Realm 小记]]></title>
      <url>/2018/01/26/Realm-%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>记录 Realm 入门级操作。</p>
<h2 id="创建-Realm-数据库文件"><a href="#创建-Realm-数据库文件" class="headerlink" title="创建 Realm 数据库文件"></a>创建 Realm 数据库文件</h2><p>Realm 默认会在 Documents 文件下创建一个default.realm文件。</p>
<p>但是考虑到，用户必须要登录到 Web 后端服务器中，并且需要支持账户快速切换功能的话。 那么可以为每个账户提供一个独立的 Realm 数据库，以此区分不同账户本地数据，并且当前账户所使用的数据库将作为默认 Realm 数据库来使用。（应用场景：1.QQ iOS 客户端 本地文件；2.聊天记录）</p>
<p>Realm 数据库文件创建是懒加载，所以只需要事先配置好目录和文件名即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</div><div class="line">    </div><div class="line"><span class="comment">// 使用默认的目录，但是请将文件名替换为用户名</span></div><div class="line">config.fileURL = [[[config.fileURL URLByDeletingLastPathComponent]</div><div class="line">                       URLByAppendingPathComponent:<span class="string">@"测试"</span>]</div><div class="line">                      URLByAppendingPathExtension:<span class="string">@"realm"</span>];</div><div class="line">    </div><div class="line"><span class="comment">// 将该配置设置为默认 Realm 配置</span></div><div class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</div><div class="line">    </div><div class="line"><span class="comment">// Realm 懒加载，所以调用时才会创建</span></div><div class="line"><span class="comment">// ... ...</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="删除-Realm-数据库文件"><a href="#删除-Realm-数据库文件" class="headerlink" title="删除 Realm 数据库文件"></a>删除 Realm 数据库文件</h2><p>在某些情况下，例如清除缓存、或者重置整个数据集之类的操作，那么就可能需要从磁盘中将 Realm 文件给完全删除掉。</p>
<p>尽管不是必须的，不过您应当将 Realm 辅助文件连同 Realm 文件一起删除，以完全清除所有的相关文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSFileManager *manager = [NSFileManager defaultManager];</div><div class="line">// 获取当前默认的 Realm 数据库</div><div class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</div><div class="line">NSArray&lt;NSURL *&gt; *realmFileURLs = @[</div><div class="line">                                    config.fileURL,</div><div class="line">                                    [config.fileURL URLByAppendingPathExtension:@&quot;lock&quot;],</div><div class="line">                                    [config.fileURL URLByAppendingPathExtension:@&quot;note&quot;],</div><div class="line">                                    [config.fileURL URLByAppendingPathExtension:@&quot;management&quot;]</div><div class="line">                                    ];</div><div class="line">for (NSURL *URL in realmFileURLs) &#123;</div><div class="line">    NSError *error = nil;</div><div class="line">    [manager removeItemAtURL:URL error:&amp;error];</div><div class="line">    if (error) &#123;</div><div class="line">        // 错误处理</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Realm 支持下述属性类型：<code>BOOL</code>、<code>bool</code>、<code>int</code>、<code>NSInteger</code>、<code>long</code>、<code>long long</code>、<code>float</code>、<code>double</code>、<code>NSString</code>、<code>NSDate</code>、<code>NSData</code> 以及 <a href="https://realm.io/cn/docs/objc/latest/#required-properties" target="_blank" rel="external">被特殊类型标记的</a> <code>NSNumber</code> 。</p>
<p><code>CGFloat</code> 属性被取消了，因为它不具备平台独立性。</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>重写 <a href="https://realm.io/cn/docs/objc/latest/api/Classes/RLMObject.html#//api/name/primaryKey" target="_blank" rel="external"><code>+primaryKey</code></a> 可以设置模型的主键。声明主键允许对象的查询和更新更加高效，并且会强制要求每个值保持唯一性。一旦将带有主键的对象添加到 Realm 数据库，那么该对象的主键将无法更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface Person : RLMObject</div><div class="line">@property NSInteger id;</div><div class="line">@property NSString *name;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">+ (NSString *)primaryKey &#123;</div><div class="line">    return @&quot;id&quot;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h3><p>Realm 将会忽略诸如 <code>nonatomic</code>、<code>atomic</code>、<code>strong</code>、<code>copy</code>、<code>weak</code> 之类的 Objective-C 属性特性。这些特性对于 Realm 存储机制而言并没有意义。Realm 有自己优化过的存储语义。所以为了避免有人对代码产生误解，我们建议您在编写模型时不要附加任何属性特性。</p>
<h3 id="属性备忘单"><a href="#属性备忘单" class="headerlink" title="属性备忘单"></a>属性备忘单</h3><table>
<thead>
<tr>
<th>类型</th>
<th>非可空值形式</th>
<th>可空值形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bool</td>
<td><code>@property BOOL value;</code></td>
<td><code>@property NSNumber&lt;RLMBool&gt; *value;</code></td>
</tr>
<tr>
<td>Int</td>
<td><code>@property int value;</code></td>
<td><code>@property NSNumber&lt;RLMInt&gt; *value;</code></td>
</tr>
<tr>
<td>Float</td>
<td><code>@property float value;</code></td>
<td><code>@property NSNumber&lt;RLMFloat&gt; *value;</code></td>
</tr>
<tr>
<td>Double</td>
<td><code>@property double value;</code></td>
<td><code>@property NSNumber&lt;RLMDouble&gt; *value;</code></td>
</tr>
<tr>
<td>String</td>
<td><code>@property NSString *value;</code></td>
<td><code>@property NSString *value;</code></td>
</tr>
<tr>
<td>Data</td>
<td><code>@property NSData *value;</code></td>
<td><code>@property NSData *value;</code></td>
</tr>
<tr>
<td>Date</td>
<td><code>@property NSDate *value;</code></td>
<td><code>@property NSDate *value;</code></td>
</tr>
<tr>
<td>Object</td>
<td>不存在：必须是可空值</td>
<td><code>@property Object *value;</code></td>
</tr>
<tr>
<td>List</td>
<td><code>@property RLMArray&lt;Class *&gt;&lt;Class&gt; *value;</code></td>
<td>不存在：必须是非可空值</td>
</tr>
<tr>
<td>LinkingObjects</td>
<td><code>@property (readonly) RLMLinkingObjects&lt;Object *&gt; *value;</code></td>
<td>不存在：必须是非可空值</td>
</tr>
</tbody>
</table>
<h2 id="Realm-关系构建"><a href="#Realm-关系构建" class="headerlink" title="Realm 关系构建"></a>Realm 关系构建</h2><p>可以通过 <code>RLMObject</code> 和 <code>RLMArray</code> 属性来关联 <code>RLMObject</code>。<code>RLMArray</code> 的接口与 <code>NSArray</code> 非常类似，并且 <code>RLMArray</code> 当中的对象可以通过索引下标来进行访问。与 <code>NSArray</code> 所不同的是，<code>RLMArray</code> 的类型是固定的，并且 只能存放一种 <code>RLMObject</code> 类型。</p>
<h3 id="多对一关系（包括一对一）"><a href="#多对一关系（包括一对一）" class="headerlink" title="多对一关系（包括一对一）"></a>多对一关系（包括一对一）</h3><p>要配置多对一或者一对一关系，在数据模型当中声明一个 <code>RLMObject</code> 子类类型的属性即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Dog.h</div><div class="line">@interface Dog : RLMObject</div><div class="line">// ... 其余属性声明</div><div class="line">@property Person *owner;</div><div class="line">@property Father *father;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>操作关系属性的方法与其他属性类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *jim = [[Person alloc] init];</div><div class="line">Dog    *rex = [[Dog alloc] init];</div><div class="line">Father *frank  = [[Father alloc] init];</div><div class="line">rex.owner = jim;</div><div class="line">rex.father = frank;</div></pre></td></tr></table></figure>
<p>由此将 Person、Father 与 Dog 建立了对应关系。</p>
<p>在使用 <code>RLMObject</code> 属性时，可以使用正常的属性访问语法来访问嵌套属性。例如，<code>rex.owner.address.country</code> 将会遍历对象图，然后自动从 Realm 中检索出每个所需的对象。</p>
<h3 id="多对多关系（包括一对多）"><a href="#多对多关系（包括一对多）" class="headerlink" title="多对多关系（包括一对多）"></a>多对多关系（包括一对多）</h3><p>让我们给 <code>Person</code> 模型添加一个 <code>dogs</code> 属性，从而让其能够与多个 <code>Dog</code> 对象建立关系。首先，我们需要定义 <code>RLMArray&lt;Dog&gt;</code> 类型，也就是在 <code>Dog</code> 模型接口定义的底部使用这条宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Dog.h</div><div class="line">@interface Dog : RLMObject</div><div class="line">// ... property declarations</div><div class="line">@end</div><div class="line"></div><div class="line">RLM_ARRAY_TYPE(Dog) // 定义 RLMArray&lt;Dog&gt; 类型</div></pre></td></tr></table></figure>
<p><code>RLM_ARRAY_TYPE</code> 宏创建了一个协议，从而允许您使用 <code>RLMArray&lt;Dog&gt;</code> 这种语法。如果这条宏没有放置在模型接口定义的底部，那么这个模型类就必须前置声明。</p>
<p>接下来，您就可以声明 <code>RLMArray&lt;Dog&gt;</code> 类型的属性了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Person.h</div><div class="line">@interface Person : RLMObject</div><div class="line">// ...其他属性声明</div><div class="line">@property RLMArray&lt;Dog *&gt;&lt;Dog&gt; *dogs;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>您可以照常对 <code>RLMArray</code> 属性进行访问和赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Jim 是 Rex 和所有名为 &quot;Fido&quot; 狗狗的主人</div><div class="line">RLMResults&lt;Dog *&gt; *someDogs = [Dog objectsWhere:@&quot;name contains &apos;Fido&apos;&quot;];</div><div class="line">[jim.dogs addObjects:someDogs];</div><div class="line">[jim.dogs addObject:rex];</div></pre></td></tr></table></figure>
<h3 id="双向关系"><a href="#双向关系" class="headerlink" title="双向关系"></a>双向关系</h3><p>关系是单向的。以 <code>Person</code> 和 <code>Dog</code> 这两个类为例。如果 <code>Person.dogs</code> 连接了一个 <code>Dog</code> 实例，那么您可以随着该连接从 <code>Person</code> 访问到对应的 <code>Dog</code>，但是是没有办法从 <code>Dog</code> 访问到对应的 <code>Person</code> 对象的。您可以设置一个一对一属性 <code>Dog.owner</code> 从而连接到 <code>Person</code>，但是这些连接实际上仍然是互相独立的。给 <code>Person.dogs</code> 添加一个 <code>Dog</code> 对象并不会将该对象的 <code>Dog.owner</code> 属性设置为对应的 <code>Person</code>。为了解决这个问题，Realm 提供了<em>连接对象</em>属性，从而表示这种双向关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface Dog : RLMObject</div><div class="line">@property NSString *name;</div><div class="line">@property NSInteger age;</div><div class="line">@property (readonly) RLMLinkingObjects *owners;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Dog</div><div class="line">+ (NSDictionary *)linkingObjectsProperties &#123;</div><div class="line">    return @&#123;</div><div class="line">        @&quot;owners&quot;: [RLMPropertyDescriptor descriptorWithClass:Person.class propertyName:@&quot;dogs&quot;],</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>借助连接对象属性，可以从特定属性获取连接到指定对象的所有对象。<code>Dog</code> 对象可以拥有一个名为 <code>owners</code> 属性，它包含所有 <code>dogs</code> 属性有该 <code>Dog</code> 对象的 <code>Person</code> 对象。将这个 <code>owners</code> 属性设置为 <code>RLMLinkingObjects</code> 类型，然后重写 <code>+[RLMObject linkingObjectsProperties]</code> 来表示 <code>owners</code> 与 <code>Person</code> 模型对象之间的关系。</p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>当定义完数据模型之后，就可以实例化 <code>RLMObject</code> 子类了， 然后还可以向 Realm 数据库中添加新的实例。以这个简单的数据模型为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Dog 数据模型</div><div class="line">@interface Dog : RLMObject</div><div class="line">@property NSString *name;</div><div class="line">@property NSInteger age;</div><div class="line">@end</div><div class="line"></div><div class="line">// Implementation</div><div class="line">@implementation Dog</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>创建新对象的方法有很多种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// (1) 创建 Dog 对象，然后设置其属性</div><div class="line">Dog *myDog = [[Dog alloc] init];</div><div class="line">myDog.name = @&quot;Rex&quot;;</div><div class="line">myDog.age = 10;</div><div class="line"></div><div class="line">// (2) 从字典中创建 Dog 对象</div><div class="line">Dog *myOtherDog = [[Dog alloc] initWithValue:@&#123;@&quot;name&quot; : @&quot;Pluto&quot;, @&quot;age&quot; : @3&#125;];</div><div class="line"></div><div class="line">// (3) 从数组中创建 Dog 对象</div><div class="line">Dog *myThirdDog = [[Dog alloc] initWithValue:@[@&quot;Pluto&quot;, @3]];</div></pre></td></tr></table></figure>
<ol>
<li>使用指定初始化函数来创建对象是最直观的方式。<strong>请注意，所有非可空属性必须在对象添加到 Realm 数据库之前完成赋值。</strong></li>
<li>通过恰当的键值，还可以使用字典来创建对象。</li>
<li>最后，<code>RLMObject</code> 的子类还可以使用数组来完成实例化。数组中的值必须与数据模型中对应的属性次序相同。</li>
</ol>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 获取默认的 Realm 数据库</div><div class="line">RLMRealm *realm = [RLMRealm defaultRealm];</div><div class="line">// （每个线程）只需执行一次</div><div class="line"></div><div class="line">// 在事务中向 Realm 数据库中添加数据</div><div class="line">[realm beginWriteTransaction];</div><div class="line">[realm addObject:myDog];</div><div class="line">[realm commitWriteTransaction];</div></pre></td></tr></table></figure>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 在事务中删除对象</div><div class="line">[realm beginWriteTransaction];</div><div class="line">[realm deleteObject:myDog];</div><div class="line">[realm commitWriteTransaction];</div><div class="line"></div><div class="line">// 从 Realm 数据库中删除所有对象</div><div class="line">[realm beginWriteTransaction];</div><div class="line">[realm deleteAllObjects];</div><div class="line">[realm commitWriteTransaction];</div></pre></td></tr></table></figure>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 在事务中更新对象</div><div class="line">[realm beginWriteTransaction];</div><div class="line">myDog.name = @&quot;Thomas Pynchon&quot;;</div><div class="line">[realm commitWriteTransaction];</div></pre></td></tr></table></figure>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>Realm 条件查询方式与 NSPredicate 类似。</p>
<ul>
<li><p>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</p>
</li>
<li><p>比较操作符 <strong>==</strong>、<strong>&lt;=</strong>、<strong>&lt;</strong>、<strong>&gt;=</strong>、<strong>&gt;</strong>、<strong>!=</strong> 和 <strong>BETWEEN</strong> 支持 <code>int</code>、<code>long</code>、<code>long long</code>、<code>float</code>、<code>double</code>以及 <code>NSDate</code> 这几种属性类型，例如 <code>age == 45</code>；</p>
</li>
<li><p>比较是否相同：<strong>==</strong> 和 <strong>!=</strong>，例如，<code>[Employee objectsWhere:@&quot;company == %@&quot;, company]</code>；</p>
</li>
<li><p>比较操作符 <strong>==</strong> 和 <strong>!=</strong> 支持布尔属性；</p>
</li>
<li><p>对于 <code>NSString</code> 和 <code>NSData</code> 属性而言，支持使用 <strong>==</strong>、<strong>!=</strong>、<strong>BEGINSWITH</strong>、<strong>CONTAINS</strong> 和 <strong>ENDSWITH</strong>操作符，例如 <code>name CONTAINS &#39;Ja&#39;</code>；</p>
</li>
<li><p>对于 <code>NSString</code> 属性而言，<strong>LIKE</strong> 操作符可以用来比较左端属性和右端表达式：<code>?</code> 和 <code>*</code> 可用作通配符，其中 <code>?</code> 可以匹配任意一个字符，<code>*</code> 匹配 0 个及其以上的字符。例如：<code>value LIKE &#39;?bc*&#39;</code> 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</p>
</li>
<li><p>字符串的比较忽略大小写，例如 <code>name CONTAINS[c] &#39;Ja&#39;</code>。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。<code>[c]</code> 修饰符可以与 <code>[d]</code> 修饰符结合使用；</p>
</li>
<li><p>字符串的比较忽略变音符号，例如 <code>name BEGINSWITH[d] &#39;e&#39;</code> 能够匹配到 <strong>étoile</strong>。这个修饰符可以与 <code>[c]</code> 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见<a href="https://realm.io/cn/docs/objc/latest/#limitations-general" target="_blank" rel="external">当前的限制</a>一节来了解详细信息。）</p>
</li>
<li><p>Realm 支持以下组合操作符：<strong>“AND”</strong>、<strong>“OR”</strong> 和 <strong>“NOT”</strong>，例如 <code>name BEGINSWITH &#39;J&#39; AND age &gt;= 32</code>；</p>
</li>
<li><p>包含操作符：<strong>IN</strong>，例如 <code>name IN {&#39;Lisa&#39;, &#39;Spike&#39;, &#39;Hachi&#39;}</code>；</p>
</li>
<li><p>空值比较：<strong>==</strong>、<strong>!=</strong>，例如 <code>[Company objectsWhere:@&quot;ceo == nil&quot;]</code>。请注意，Realm 将 <code>nil</code> 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，<code>nil</code> 等同于自身；</p>
</li>
<li><p><strong>ANY 比较</strong>，例如 <code>ANY student.age &lt; 21</code>；</p>
</li>
<li><p><code>RLMArray</code> 和 <code>RLMResults</code> 属性支持聚集表达式：<strong>@count</strong>、<strong>@min</strong>、<strong>@max</strong>、<strong>@sum</strong> 和 <strong>@avg</strong>，例如 <code>[Company objectsWhere:@&quot;employees.@count &gt; 5&quot;]</code> 可用以检索所有拥有 5 名以上雇员的公司。</p>
</li>
<li><p>支持子查询，不过存在以下限制：</p>
</li>
</ul>
<ul>
<li><strong>@count</strong> 是唯一一个能在 <strong>SUBQUERY</strong> 表达式当中使用的操作符；</li>
<li><code>SUBQUERY(…).@count</code> 表达式只能与常量相比较；</li>
<li>目前仍不支持关联子查询。</li>
</ul>
<p>关于谓词请阅读👉<a href="http://www.cocoachina.com/ios/20160111/14926.html" target="_blank" rel="external">iOS中的谓词（NSPredicate）使用</a></p>
]]></content>
      
        <categories>
            
            <category> 工具集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Realm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xcode Tips]]></title>
      <url>/2017/09/22/Xcode-Tips/</url>
      <content type="html"><![CDATA[<p><img src="/2017/09/22/Xcode-Tips/Xcode Tips.png" alt=""> </p>
<a id="more"></a>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="MARK-、TODO-、BUG"><a href="#MARK-、TODO-、BUG" class="headerlink" title="MARK 、TODO 、BUG"></a>MARK 、TODO 、BUG</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MARK: -作记号内容</span></div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> -需要完成的任务描述</span></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> -需要修复BUG的描述</span></div></pre></td></tr></table></figure>
<h3 id="添加警告"><a href="#添加警告" class="headerlink" title="添加警告"></a>添加警告</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#warning <span class="meta-string">"警告的描述"</span></span></div></pre></td></tr></table></figure>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="shift-command-o"><a href="#shift-command-o" class="headerlink" title="shift + command + o"></a>shift + command + o</h3><blockquote>
<p>快速搜索文件，以及搜索方法名定位方法实现代码</p>
</blockquote>
<h3 id="control-6"><a href="#control-6" class="headerlink" title="control + 6"></a>control + 6</h3><blockquote>
<p>快速定位想编辑的方法</p>
<p>列出当前文件中所有的方法，可以通过输入关键字来过滤</p>
</blockquote>
<h3 id="shift-command-j"><a href="#shift-command-j" class="headerlink" title="shift + command + j"></a>shift + command + j</h3><blockquote>
<p>打开对应文件的目录</p>
</blockquote>
<h3 id="control-i"><a href="#control-i" class="headerlink" title="control + i"></a>control + i</h3><blockquote>
<p>方法名中<code>：</code>上下对齐排版</p>
</blockquote>
<h3 id="option-command-左右键"><a href="#option-command-左右键" class="headerlink" title="option + command + 左右键"></a>option + command + 左右键</h3><blockquote>
<p>收起 &amp; 展开 代码段</p>
</blockquote>
<h3 id="control-command-上下键"><a href="#control-command-上下键" class="headerlink" title="control + command + 上下键"></a>control + command + 上下键</h3><blockquote>
<p>在.h和.m文件之间切换</p>
</blockquote>
<h3 id="command-return"><a href="#command-return" class="headerlink" title="command + return"></a>command + return</h3><blockquote>
<p>切换成 standsrd editor</p>
</blockquote>
<h3 id="command-option-return"><a href="#command-option-return" class="headerlink" title="command + option + return"></a>command + option + return</h3><blockquote>
<p>切换成 assistan editor</p>
</blockquote>
<h3 id="左侧、右侧、底部工具栏"><a href="#左侧、右侧、底部工具栏" class="headerlink" title="左侧、右侧、底部工具栏"></a>左侧、右侧、底部工具栏</h3><h4 id="command-shift-Y"><a href="#command-shift-Y" class="headerlink" title="command + shift + Y"></a>command + shift + Y</h4><blockquote>
<p>切换底部 Console VIew 显示或者隐藏</p>
</blockquote>
<h4 id="command-0"><a href="#command-0" class="headerlink" title="command + 0"></a>command + 0</h4><blockquote>
<p>切换左边导航区（Navigator）显示或者隐藏</p>
</blockquote>
<h4 id="command-option-0"><a href="#command-option-0" class="headerlink" title="command + option + 0"></a>command + option + 0</h4><blockquote>
<p>切换右边工具区（Utility）显示或者隐藏</p>
</blockquote>
<h3 id="Tab栏"><a href="#Tab栏" class="headerlink" title="Tab栏"></a>Tab栏</h3><h4 id="command-T"><a href="#command-T" class="headerlink" title="command + T"></a>command + T</h4><blockquote>
<p>新建一个Tab栏</p>
</blockquote>
<h4 id="command-shift-或者"><a href="#command-shift-或者" class="headerlink" title="command + shift + [ 或者 ]"></a>command + shift + [ 或者 ]</h4><blockquote>
<p>Tab栏左右切换</p>
</blockquote>
<h2 id="开启无线调试"><a href="#开启无线调试" class="headerlink" title="开启无线调试"></a>开启无线调试</h2><p>前提： <code>iOS 11 + Xcode 9</code>  以上设备</p>
<p>步骤： </p>
<ul>
<li>用数据线链接设备</li>
<li><code>Window</code> -&gt; <code>Device and Simulators</code></li>
<li>找到对应设备，勾选 <code>Connect via network</code></li>
<li>断开数据线，运行即可。</li>
</ul>
<p>只需操作一次，之后开启Xcode会自动连接。</p>
<p>持续整理更新。。。</p>
]]></content>
      
        <categories>
            
            <category> 工具集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC 常量]]></title>
      <url>/2017/09/18/OC%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p><img src="/2017/09/18/OC常量与变量/OC常量与变量.png" alt=""> </p>
<a id="more"></a>
<h2 id="全局常量的常见用法"><a href="#全局常量的常见用法" class="headerlink" title="全局常量的常见用法"></a>全局常量的常见用法</h2><p>通过 <code>FOUNDATION_EXPORT</code> 定义全局常量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .h文件</span></div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</div><div class="line"></div><div class="line"><span class="comment">// .m文件</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification = <span class="string">@"com.alamofire.networking.reachability.change"</span>;</div></pre></td></tr></table></figure>
<p>通过 <code>extern</code> 和 <code>const</code> 定义全局常量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .h文件</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> YLConstApplyResultForRefuseIcon;</div><div class="line"></div><div class="line"><span class="comment">// .m文件</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> YLConstApplyResultForRefuseIcon = <span class="string">@"approval-refuse"</span>;</div></pre></td></tr></table></figure>
<h2 id="局部常量的常见用法"><a href="#局部常量的常见用法" class="headerlink" title="局部常量的常见用法"></a>局部常量的常见用法</h2><p>方法内的常量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存</span></div><div class="line"><span class="keyword">static</span> XYGCDAsyncSocketManager *staticInstance = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div></pre></td></tr></table></figure>
<p>方法体外，类内部使用的常量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAFMultipartFormCRLF = <span class="string">@"\r\n"</span>;</div></pre></td></tr></table></figure>
<h2 id="const修饰符说明"><a href="#const修饰符说明" class="headerlink" title="const修饰符说明"></a>const修饰符说明</h2><ul>
<li>const用来修饰右边的基本变量或指针变量</li>
<li>被修饰的变量只读，不能被修改</li>
</ul>
<h2 id="static修饰符说明"><a href="#static修饰符说明" class="headerlink" title="static修饰符说明"></a>static修饰符说明</h2><p>修饰局部变量:   </p>
<ul>
<li>在方法体内，声明为静态的变量（局部静态变量）。保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存，生命周期类似全局变量了，但是作用域不变。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单例</span></div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedInstance &#123;</div><div class="line">    <span class="keyword">static</span> XYGCDAsyncSocketManager *staticInstance = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        staticInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> staticInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在方法体外，类内部使用的常量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAFMultipartFormCRLF = <span class="string">@"\r\n"</span>;</div></pre></td></tr></table></figure>
<h2 id="extern修饰符说明"><a href="#extern修饰符说明" class="headerlink" title="extern修饰符说明"></a>extern修饰符说明</h2><ul>
<li>声明外部全局变量,这里需要特别注意extern只能声明，不能用于实现。</li>
</ul>
<h2 id="FOUNDATION-EXPORT-与-＃define"><a href="#FOUNDATION-EXPORT-与-＃define" class="headerlink" title="FOUNDATION_EXPORT 与 ＃define"></a>FOUNDATION_EXPORT 与 ＃define</h2><p><code>FOUNDATION_EXPORT</code> 与 <code>＃define</code> 都可以用来定义常量的。</p>
<p><code>FOUNDATION_EXPORT</code> 定义的常量可以直接使用 <code>myString == MyFirstConstant</code> 来比较, 而 <code>define</code> 则使用的是 <code>[myString isEqualToString:MyFirstContant]</code> 。</p>
<ul>
<li><code>FOUNDATION_EXPORT</code> 是直接比较指针地址。</li>
<li><code>define</code> 则是一一比较字符串的每一个字符是否相等。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Objective-C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 源码阅读笔记]]></title>
      <url>/2017/08/08/AFNetworking-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><img src="/2017/08/08/AFNetworking-阅读笔记/AFNetworking.png" alt=""> </p>
<a id="more"></a>
<h2 id="框架中用到的一些宏"><a href="#框架中用到的一些宏" class="headerlink" title="框架中用到的一些宏"></a>框架中用到的一些宏</h2><h3 id="DEPRECATED-ATTRIBUTE"><a href="#DEPRECATED-ATTRIBUTE" class="headerlink" title="DEPRECATED_ATTRIBUTE"></a><code>DEPRECATED_ATTRIBUTE</code></h3><p>在声明属性或者方法时，在后面加上 <code>DEPRECATED_ATTRIBUTE</code>，可以用来标识该方法将会被慢慢弃用属性或接口的，当我们不想让别人再用这属性或接口时，可以加上这个宏，如果别人仍然调用，则编译器会报警告。  </p>
<p>此宏常用于框架迭代时，新旧方法和属性替换的过渡阶段。 （⚠️ 必需放在”;”前）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AFNetworking 3.0 框架中即将被弃用的POST请求</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">                       success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">                       failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line">                       </div><div class="line"><span class="comment">// 在属性声明时加入 DEPRECATED_ATTRIBUTE 表明此属性将会被弃用                      </span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> *baseURL DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure>
<h3 id="NS-DESIGNATED-INITIALIZER"><a href="#NS-DESIGNATED-INITIALIZER" class="headerlink" title="NS_DESIGNATED_INITIALIZER"></a><code>NS_DESIGNATED_INITIALIZER</code></h3><p>此宏的意思是最终被指定的初始化方法，在一个类的<code>interface</code>中只能用一次，而且必须是以<code>init</code>开头的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIContentContainer通过xib初始化实例对象</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="keyword">nullable</span> <span class="built_in">NSBundle</span> *)nibBundleOrNil <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></td></tr></table></figure>
<h3 id="NS-ASSUME-NONNULL-BEGIN-与-NS-ASSUME-NONNULL-END"><a href="#NS-ASSUME-NONNULL-BEGIN-与-NS-ASSUME-NONNULL-END" class="headerlink" title="NS_ASSUME_NONNULL_BEGIN 与 NS_ASSUME_NONNULL_END"></a><code>NS_ASSUME_NONNULL_BEGIN</code> 与 <code>NS_ASSUME_NONNULL_END</code></h3><p>请看<a href="#nullable和nonnull"><code>nullable</code> 和 <code>nonnull</code> </a>  </p>
<p> <span id="FOUNDATION_EXPORT"></span></p>
<h3 id="FOUNDATION-EXPORT"><a href="#FOUNDATION-EXPORT" class="headerlink" title="FOUNDATION_EXPORT"></a><code>FOUNDATION_EXPORT</code></h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</div></pre></td></tr></table></figure>
<p><code>FOUNDATION_EXPORT</code>与 <code>＃define</code>都可以用来定义常量的。</p>
<p><code>FOUNDATION_EXPORT</code>定义的常量可以直接使用(myString == MyFirstConstant)来比较, 而<code>define</code>则使用的是([myString isEqualToString:MyFirstContant])。  </p>
<ul>
<li><code>FOUNDATION_EXPORT</code>是直接比较指针地址。   </li>
<li><code>define</code>则是一一比较字符串的每一个字符是否相等。</li>
</ul>
<p>更多常量说明请查阅<a href="#关于全局常量">关于全局常量</a></p>
<h3 id="NS-UNAVAILABLE"><a href="#NS-UNAVAILABLE" class="headerlink" title="NS_UNAVAILABLE"></a><code>NS_UNAVAILABLE</code></h3><p>告诉编译器方法不可用，如果使用了就会编译失败，提示错误。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</div></pre></td></tr></table></figure>
<h3 id="Require-Quiet-和-Require-noErr-Quiet"><a href="#Require-Quiet-和-Require-noErr-Quiet" class="headerlink" title="__Require_Quiet 和 __Require_noErr_Quiet"></a><code>__Require_Quiet</code> 和 <code>__Require_noErr_Quiet</code></h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</div><div class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</div><div class="line">    SecCertificateRef allowedCertificate;</div><div class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</div><div class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</div><div class="line">    SecTrustResultType result;</div><div class="line"></div><div class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</div><div class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</div><div class="line"></div><div class="line">    policy = SecPolicyCreateBasicX509();</div><div class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</div><div class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</div><div class="line"></div><div class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</div><div class="line"></div><div class="line">_<span class="keyword">out</span>:</div><div class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</div><div class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (policy) &#123;</div><div class="line">        <span class="built_in">CFRelease</span>(policy);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</div><div class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> allowedPublicKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__Require_Quiet</code>可以看出这个宏的用途是：当条件返回false时，执行标记以后的代码。<br><code>__Require_noErr_Quiet</code>可以看出这个宏的用途是：当条件抛出异常时，执行标记以后的代码。</p>
<h2 id="nullable-和-nonnull"><a href="#nullable-和-nonnull" class="headerlink" title="nullable 和 nonnull"></a><code>nullable</code> 和 <code>nonnull</code></h2><p>从字面上我们可以猜到，<code>nullable</code>表示对象可以是<code>NULL</code>或<code>nil</code>，而<code>nonnull</code>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 属性声明的三种修饰方式</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> * baseURL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> * _Nullable baseURL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> * __<span class="keyword">nullable</span> baseURL;</div><div class="line"></div><div class="line"><span class="comment">// 方法返回值与方法参数时修饰</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">                              progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgress</div><div class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
<p>而对于 双指针类型对象 、 <code>Block</code> 的返回值 、 <code>Block</code> 的参数 等，这时候就不能用 <code>nonnull/nullable</code> 修饰，只能用带下划线的 <code>__nonnull/__nullable</code> 或者 <code>_Nonnull/_Nullable</code>。</p>
<p>在AFNetworking框架中可见  </p>
<ul>
<li>属性、方法返回值、方法参数的修饰，使用： <code>nonnull/nullable</code></li>
<li>Block 的参数、Block 返回值的修饰，使用： <code>_Nonnull/_Nullable</code></li>
</ul>
<p><span id="nullable和nonnull"></span></p>
<p>如果需要每个属性或每个方法都去指定 <code>nonnull</code> 和 <code>nullable</code> ，将是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏： <code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code> 。在这两个宏之间的代码，所有简单指针对象都被假定为 <code>nonnull</code> ，因此我们只需要去指定那些 <code>nullable</code> 指针对象即可。AFNetworking框架中做了如此的操作。</p>
<p><a href="http://blog.csdn.net/bravegogo/article/details/52458403" target="_blank" rel="external"><code>nullable</code>、<code>__nullable</code>、<code>_Nullable</code> 究竟有什么区别呢？</a></p>
<h2 id="amp-与"><a href="#amp-与" class="headerlink" title="&amp; 与 @"></a><code>&amp;</code> 与 <code>@</code></h2><ul>
<li><code>&amp;</code> 表示取地址的意思，和C语言一样</li>
<li><code>@</code> 表示字面量</li>
</ul>
<p><a href="http://www.jianshu.com/p/e89bd39e4849" target="_blank" rel="external">ios中的字面量语法</a></p>
<h2 id="name和-pragma-mark"><a href="#name和-pragma-mark" class="headerlink" title="@name和 #pragma mark"></a><code>@name</code>和 <code>#pragma mark</code></h2><p><code>AFNetworking</code>作者使用了<code>@name</code>来分隔 <code>.h</code> 文件中中不同功能代码。在 <code>.m</code> 文件中用<code>#pragma mark</code>分隔不同功能代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">///---------------------</span></div><div class="line"><span class="comment">/// @name Initialization</span></div><div class="line"><span class="comment">///---------------------</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSCopying</span></div></pre></td></tr></table></figure>
<h2 id="pragma-clang-diagnostic-ignored"><a href="#pragma-clang-diagnostic-ignored" class="headerlink" title="#pragma clang diagnostic ignored"></a><code>#pragma clang diagnostic ignored</code></h2><p>首先, <code>#pragma</code> 本质上也是声明，一般常用的功能就是打注释、尤其是分段注释,但是 <code>#pragma</code> 另外一个强大的功能就是处理编译器警告，用的时候可能就没上一个,功能用的那么多，在代码中处理警告却是极其高效的方法。</p>
<p>其中 <code>clang diagnostic</code> 便是 <code>#pragma</code> 第一个功能常用的命令，步骤如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma clang diagnostic push  </span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-相关命令"</span>  </span></div><div class="line"><span class="comment">// 你自己的代码  </span></div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>
<p>常用 “-相关命令”  :</p>
<ul>
<li>方法弃用告警 <code>&quot;-Wdeprecated-declarations&quot;</code>  </li>
<li>不兼容指针类型 <code>&quot;-Wincompatible-pointer-types&quot;</code>  </li>
<li>循环引用 <code>&quot;-Warc-retain-cycles&quot;</code>  </li>
<li>未使用变量 <code>&quot;-Wunused-variable&quot;</code>     </li>
</ul>
<p><a href="http://clang.llvm.org/docs/UsersManual.html#diagnostics_pragma
s" target="_blank" rel="external">“-相关命令” 列表</a><br><a href="http://nshipster.cn/pragma/" target="_blank" rel="external">#pragma</a></p>
<p><span id="关于全局常量"></span></p>
<h2 id="关于全局常量"><a href="#关于全局常量" class="headerlink" title="关于全局常量"></a>关于全局常量</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .h</span></div><div class="line"></div><div class="line"><span class="comment">///--------------------</span></div><div class="line"><span class="comment">/// @name Notifications</span></div><div class="line"><span class="comment">///--------------------</span></div><div class="line"></div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification;</div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification = <span class="string">@"com.alamofire.networking.reachability.change"</span>;</div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem = <span class="string">@"AFNetworkingReachabilityNotificationStatusItem"</span>;</div></pre></td></tr></table></figure>
<p>AFNetworking框架中通知的字符串封装到发通知的文件中（AFNetworkReachabilityManager类），同时在文件内部按不同模块进行区分。</p>
<p>通知的字符串的声明在.h 赋值在.m中，可以防止在.h中被修改。</p>
<p> 仔细看通知的字符串的命名。可以发现</p>
<ul>
<li>类名 + 业务相关（动词） + Notification </li>
<li>类名 + Notification + 业务相关（名词）</li>
</ul>
<p><a href="#FOUNDATION_EXPORT"><code>FOUNDATION_EXPORT</code> </a> 的用法请查看<code>框架中用到的一些宏</code>模块。<br><a href="http://blog.csdn.net/qq_32010299/article/details/51836806" target="_blank" rel="external">关于FOUNDATION_EXTERN、extern、FOUNDATION_EXPORT、extern “C”的区别</a></p>
<p>通常会写一个方法通过<code>枚举</code>和<code>switch</code>返回对应的字符串，在<code>AFNetworking</code>框架中看到一种骚气的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在.h声明</span></div><div class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status);</div><div class="line"></div><div class="line"><span class="comment">// 在.m实现</span></div><div class="line"><span class="built_in">NSString</span> * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    <span class="keyword">switch</span> (status) &#123;</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Not Reachable"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Reachable via WWAN"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Reachable via WiFi"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusUnknown:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Unknown"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">AFStringFromNetworkReachabilityStatus(<span class="keyword">self</span>.networkReachabilityStatus);</div></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/064b5b82a3a2" target="_blank" rel="external">iOS常量(const)、enum、宏(#define)的使用场景及区别</a></p>
<h2 id="关于局部常量"><a href="#关于局部常量" class="headerlink" title="关于局部常量"></a>关于局部常量</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> <span class="keyword">const</span> batchSize = <span class="number">50</span>;</div></pre></td></tr></table></figure>
<h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>TO-DO </p>
<h2 id="类中的私有方法"><a href="#类中的私有方法" class="headerlink" title="类中的私有方法"></a>类中的私有方法</h2><p>在AFNetworking框架中把私有方法写成<code>static void funcName()</code> 这样的<code>C函数</code>，并且写在<code>@interface</code>上方。</p>
<ul>
<li>写在在文件的最前方，比较容易查找</li>
<li>可以适当的使用内联函数，提高效率。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFPostReachabilityStatusChange(<span class="built_in">SCNetworkReachabilityFlags</span> flags, AFNetworkReachabilityStatusBlock block) &#123;</div><div class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">if</span> (block) &#123;</div><div class="line">            block(status);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSNotificationCenter</span> *notificationCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</div><div class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</div><div class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class="literal">nil</span> userInfo:userInfo];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ifdef-ifndef-if-else-endif"><a href="#ifdef-ifndef-if-else-endif" class="headerlink" title="#ifdef #ifndef #if #else #endif"></a>#ifdef #ifndef #if #else #endif</h2><p><a href="http://blog.csdn.net/wwwang89123/article/details/17436577" target="_blank" rel="external">Objective–C语言预处理命令之条件编译（#ifdef,#else,#endif,#if等）</a>  </p>
<p>当必须要对条件进行判断的时候，我们有下边几种方案了</p>
<ul>
<li><code>#ifdef</code> 这个是编译特性</li>
<li><code>if else</code> 代码层次的判断</li>
<li><code>__Require_XXX</code> 宏</li>
</ul>
<h2 id="continue、break、return的区别"><a href="#continue、break、return的区别" class="headerlink" title="continue、break、return的区别"></a>continue、break、return的区别</h2><ul>
<li><code>break</code><br>多用于循环语句，如<code>for</code>、<code>while</code> 、<code>switch</code>。当程序执行到<code>break</code>时在循环中表示结束整个循环,而且在多层嵌套中，一个break只能跳出一层循环。<ul>
<li><code>continue</code><br>用于在循环体中进行跳转，当程序执行到continue时，表示忽略其后面的代码（或者说结束本次循环），继续执行下一次循环。  </li>
</ul>
</li>
<li><code>return</code><br>表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，由return后面的参数指定。      </li>
</ul>
<h2 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h2><p><a href="http://www.jianshu.com/p/650ad90bf563" target="_blank" rel="external">简单粗暴系列之HTTPS原理</a><br><a href="http://www.jianshu.com/p/5969bbb4af9f" target="_blank" rel="external">别说你会AFNetworking3.0/NSURLSession</a><br><a href="http://www.jianshu.com/p/4102b817ff2f" target="_blank" rel="external">正确使用AFNetworking的SSL保证网络安全</a><br><a href="http://www.jianshu.com/p/a9bca62d8dab" target="_blank" rel="external">与时俱进，HTTP/2下的iOS网络层架构设计</a><br><a href="http://www.jianshu.com/p/9c1979ef2a70" target="_blank" rel="external">移动基础设施的建设</a></p>
<h2 id="NSSecureCoding"><a href="#NSSecureCoding" class="headerlink" title="NSSecureCoding"></a>NSSecureCoding</h2><p><a href="http://blog.jobbole.com/67655/" target="_blank" rel="external">使用NSSecureCoding协议进行对象编解码</a></p>
<h2 id="NSCopying"><a href="#NSCopying" class="headerlink" title="NSCopying"></a>NSCopying</h2><p><a href="http://www.jianshu.com/p/e98e6e30ebda" target="_blank" rel="external">iOS中几个常用协议（一）NSCopying/NSMutableCopying</a>  </p>
<h2 id="NSIndexSet"><a href="#NSIndexSet" class="headerlink" title="NSIndexSet"></a>NSIndexSet</h2><p><a href="http://www.jianshu.com/p/84a1d5296844" target="_blank" rel="external">NSIndexSet 用法</a></p>
<p>未完待续…</p>
]]></content>
      
        <categories>
            
            <category> Objective-C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OC </tag>
            
            <tag> AFNetworking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剪不断理还乱,是架构]]></title>
      <url>/2017/08/03/%E6%8E%A2%E5%AF%BB%E6%9C%80%E9%80%82%E5%90%88%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<p><img src="/2017/08/03/探寻最适合业务的架构/探寻最适合业务的架构.png" alt=""> </p>
<a id="more"></a>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>在 iOS 开发中，MVC（Model View Controller）是构建iOS App的标准模式，是苹果推荐的一个用来组织代码的权威范式。</p>
<p>所谓的 MVC 是指：  </p>
<ul>
<li>Model: 数据的拥有者，实现具体的业务逻辑。  </li>
<li>View: 具体的用户界面。  </li>
<li>Controller: 负责将 View 中用户的动作传达给 Model，将 Model 的数据通过 View 展现出来。   </li>
</ul>
<h3 id="关于Controller的臃肿问题"><a href="#关于Controller的臃肿问题" class="headerlink" title="关于Controller的臃肿问题"></a>关于Controller的臃肿问题</h3><p>Controller 里面就只应该存放这些不能复用的代码，这些代码包括：  </p>
<ul>
<li>在初始化时，构造相应的 View 和 Model。  </li>
<li>监听 Model 层的事件，将 Model 层的数据传递到 View 层。  </li>
<li>监听 View 层的事件，并且将 View 层的事件转发到 Model 层。  </li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="/2017/08/03/探寻最适合业务的架构/MVVM框架.png" alt="MVVM框架">   </p>
<p>如图：MVVM 框架是 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。  </p>
<p>基于 MVVM 设计思路，ViewModel 存在目的在于抽离 ViewController 中展示业务逻辑，而不是替代 ViewController，其它视图操作业务等还是应该放在 ViewController 中实现。</p>
<p>MVVM 框架中数据流向可以表示为 ViewModel -&gt; ViewController -&gt; View 。</p>
<ul>
<li>注意：ViewModel 既然不负责视图操作逻辑，ViewModel 中就不应该存在任何View对象，更不应该存在 Push/Present 等视图跳转逻辑。因此，ViewModel 中绝不应该存在任何视图操作相关的代码。同理View中也不该导入Model（但是这一点的确很难做到）。</li>
</ul>
<p><strong>view-model</strong> 一词的确不能充分表达我们的意图。 一个更好的术语可能是 “ View Coordinator ”(感谢<a href="https://twitter.com/kastiglione" target="_blank" rel="external">Dave Lee</a>提的这个 “View Coordinator” 术语, 真是个好点子)。你可以认为它就像是电视新闻主播背后的研究人员和作家团队。 它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。摘自<a href="http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/" target="_blank" rel="external">《ReactiveCocoa 和 MVVM 入门》</a></p>
<h2 id="更适合项目业务的架构"><a href="#更适合项目业务的架构" class="headerlink" title="更适合项目业务的架构"></a>更适合项目业务的架构</h2><p><img src="/2017/08/03/探寻最适合业务的架构/iOS架构.png" alt="实验中到框架"></p>
<p>由于目前项目是按模块开发，从每个独立的功能模块考虑，单个模块适合 MVC 为基础，分离出网络层、界面拼装层、ViewModel 层、数据持久化层等等层次架构。减少 ViewController 中的代码，降低 View 和 Model 的耦合。</p>
<p>并且不会对现有的 MVC 架构产生大的影响，更多的是把 ViewController 中的代码分离到各个层中。</p>
<h3 id="网络请求层"><a href="#网络请求层" class="headerlink" title="网络请求层"></a>网络请求层</h3><p>网络请求层请求服务器转化成 Model 数据，再由 ViewModel 层处理成View需要的数据，通过 ViewController 传递给 View。</p>
<p>个人认为将一个网络请求封装成一个类会是完美的封装  </p>
<ul>
<li>自己管理自己的 URL</li>
<li>自己管理自己的错误码</li>
<li>验证服务器返回内容（数据类型验证）</li>
<li>缓存数据</li>
<li>More … …</li>
</ul>
<p>一个存粹网络请求类，不该在其中处理数据，将数据处理的过程放在 ViewModel 中，以降低与 Model 的耦合。</p>
<h3 id="界面拼装层"><a href="#界面拼装层" class="headerlink" title="界面拼装层"></a>界面拼装层</h3><p>构造专门的 UIView 的子类，来负责控件的拼装。不过稍微麻烦一些的是，需要把这些控件的事件回调先接管，再都一一暴露回 ViewController。</p>
<p>我希望的是 View 和 Model 能完全的分离，这样做的优势在于，ViewModel、Model 和网络请求可以最大限度的重用。假设有一天需要给我们的 iPhone 项目开发 iPad 版本，甚至 macOS 版本，那么我们可以预想到，我们只需重新布局界面，而展示的数据结构不会有大大变化，ViewModel、Model 和网络请求即可重用。</p>
<h3 id="ViewModel层"><a href="#ViewModel层" class="headerlink" title="ViewModel层"></a>ViewModel层</h3><p>View 只接受 ViewModel 处理完之后的数据，而 ViewController 只需要传递 ViewModel 处理后的数据。  </p>
<p>更多关于 ViewModel 介绍请查阅 <a href="https://objccn.io/issue-13-1/" target="_blank" rel="external">MVVM 介绍</a></p>
<h3 id="推送层"><a href="#推送层" class="headerlink" title="推送层"></a>推送层</h3><ul>
<li>APNS推送</li>
<li>Socket推送</li>
</ul>
<p>封装如下：  </p>
<ul>
<li>将推送的标识封装在一个头文件中，声明成全局常量。</li>
<li>将每个推送对应的操作封装在一个文件中，收到推送调用对应的方法。</li>
</ul>
<h3 id="数据持久化层"><a href="#数据持久化层" class="headerlink" title="数据持久化层"></a>数据持久化层</h3><p>若单个模块需要做数据存取，就将数据存取放在专门的类中处理。</p>
<h3 id="其他层"><a href="#其他层" class="headerlink" title="其他层"></a>其他层</h3><ul>
<li>模块中的全局常量</li>
<li>与其他模块通用类</li>
</ul>
<h2 id="一些有趣的思考"><a href="#一些有趣的思考" class="headerlink" title="一些有趣的思考"></a>一些有趣的思考</h2><h3 id="在什么地方发起网络请求的问题"><a href="#在什么地方发起网络请求的问题" class="headerlink" title="在什么地方发起网络请求的问题"></a>在什么地方发起网络请求的问题</h3><p>个人认为在ViewModel中发起请求会是一个不错的选中。</p>
<p>ViewController 向 ViewModel 提供请求所需放参数，在 ViewModel 中发起请求，转成 Model-Data，接管该数据处理成 View 需要的数据。</p>
<h3 id="列表数据的处理问题"><a href="#列表数据的处理问题" class="headerlink" title="列表数据的处理问题"></a>列表数据的处理问题</h3><p>MVC 的架构中在，从网络请求中获取列表数据，转换成模型数据 Array，再从 Array 中取出 Cell 对应的 Model 并赋值。这是我们通常的做法。</p>
<p>但是从本文 MVVM 框架图中可见，MVVM 架构 Model 只与 ViewModel 交互，并不会直接传递到 Viewcontroller，所以我能想到的一种做法，是给 Cell 创建对应的 CellViewModel ，tableView 生成  tableViewViewModel ，通过这些 ViewModel 给对应 View 赋值。</p>
<p>以此<code>JSON</code>数据为例，展示 MVC 与 MVVM 的区别：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"Data": &#123;</div><div class="line">        "PageSize": 1,</div><div class="line">        "PageIndex": 2,</div><div class="line">        "TotalCount": 1,</div><div class="line">  	    "TotalAmount": [&#123;"Month": 1,</div><div class="line">					    "Total": "100"&#125;], 	 	</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>Model 在我看来更像是一种数据存储的格式。</p>
<p>将以上<code>JSON</code>数据转换成以下 Model 。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TotalAmountModel</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> month;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *total;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DataModel</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> pageSize;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> pageIndex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> totalCount;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;TotalAmountModel *&gt; *totalAmount;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>通常在 MVC 中，我就习惯将 DataModel 直接抛给 ViewController ，所有的处理立即在 ViewController 完成。</p>
<p>MVVM 则是创建 DataViewModel 来处理成能直接赋值给 View 的数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TotalAmountViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *month;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *total;</div><div class="line">- (<span class="keyword">instancetype</span>)initWithModel:(TotalAmountModel *)model;</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TotalAmountViewModel</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithModel:(TotalAmountModel *)model &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        _month = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld月兑换记录"</span>,(<span class="keyword">long</span>)model.month];</div><div class="line">        _total = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"合计：%@元"</span>,model.total];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DataViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> pageSize;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> pageIndex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> totalCount;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;TotalAmountViewModel *&gt; *totalAmount;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="external">被误解的MVC和被神化的MVVM</a>   </li>
<li><a href="http://www.cocoachina.com/ios/20170710/19801.html" target="_blank" rel="external">MVVM与Controller瘦身实践</a>  </li>
<li><a href="http://www.jianshu.com/p/eedbc820d40a" target="_blank" rel="external">杂谈: MVC/MVP/MVVM</a>  </li>
<li><a href="http://www.cocoachina.com/ios/20170717/19884.html" target="_blank" rel="external">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软件架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MVC </tag>
            
            <tag> MVVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPod工作原理]]></title>
      <url>/2017/07/09/CocoaPod%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p><img src="/2017/07/09/CocoaPod工作原理/CocoaPod工作原理.png" alt="&quot;CocoaPod工作原理图解&quot;"><br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> 工具集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cocoapods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World,Goodbey HDU]]></title>
      <url>/2017/06/14/Hello-World-Goodby-HDU/</url>
      <content type="html"><![CDATA[<p><img src="/2017/06/14/Hello-World-Goodby-HDU/001.png" alt="&quot;我们毕业啦&quot;"><br><a id="more"></a><br>打算写这篇文章很久了，总在起笔时欲言又止，脑海晃过一个个画面，不知该从何说起。</p>
<p>不如，从头开始。  </p>
<p>我记得那是一个下雨的日子，江南常有的雨天，天真的少年就这样闯进了文一路的杭电。<br>也许大学是从梧桐树斑驳光影下的军训开始的，也许是从工字楼213五个人初见开始的，也许是从第一行C代码”Hello World”开始的。 </p>
<p>就在懵懵懂懂中开始了。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/003.png" alt="&quot;文一校区 梧桐树&quot;"></p>
<p>那时的东阳赌神还在炸金花，那时的柯桥富帅还没修学，那时的河北宗文帮我们搞定了很多代码，那时的河南蒲少爱上了页游。  </p>
<p>还有那个少年，他们叫他Hreo,他说他喜欢漫威里超级英雄Bumblebee。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/002.png" alt="&quot;赌神，你们为什么没有在一起？&quot;"> </p>
<p>大一。 </p>
<p>熙熙攘攘的社团，组团吃喝玩乐的文一路，度日如年的晚自习。<br>体育课上的太极十八式，马克思主义课上的小胖老师，点名考勤的红白卡。<br>学校对面重庆麻辣烫的阿姨，这一次葱蒜麻辣我都要。<br>沙县大酒店的蒸饺。<br>炸鸭腿饭的老板，加一瓶可乐。<br>还有到现在还不怎么会的C语言。 </p>
<p>你们都还在吗？</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/004.png" alt="&quot;田北的支教时光&quot;"> </p>
<p>田北小学的孩子们，你们都长大了吗？</p>
<p>可那个少年还是一个孩子。</p>
<p>大二。</p>
<p>洋溢。<br>你好吗？<br>B支4依旧在文一和下沙之间穿梭。</p>
<p>人生是一场错过。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/006.png" alt="&quot;田北的支教时光&quot;"></p>
<p>西藏。<br>仓央嘉措和玛吉阿米的拉萨。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/009.png" alt="&quot;一个人需要隐藏多少秘密才能巧妙地度过一生&quot;"></p>
<p>曾虑多情损梵行，入山又恐别倾城。<br>世间安得双全法，不负如来不负卿。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/005.png" alt="&quot;纳木措&quot;"></p>
<p>大三。 </p>
<p>王大全老师，您的又大又全理论我想我能理解。<br>谢谢您带我领略软件工程的工程思维。<br>您的面壁蹲墙功我不会忘。<br>愿您，好好的。<br>相信师母，已变成了天使，从此没有忧伤。</p>
<p>实验室里的翔哥，耐心的讲解着OC代码。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/007.png" alt="&quot;回不去了&quot;"></p>
<p>WANG：你为什么要写iOS项目交作业。<br>ME：我就喜欢。<br>王老师我这回答你可满意？<br>从此走上了iOS Developer的不归路。  </p>
<p>美国。<br>纽约。波士顿。奥兰多。迈阿密。洛杉矶。</p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/010.png" alt="&quot;Key West, Florida&quot;"></p>
<p>大四。</p>
<p>代码。毕设。离别。实习。租房。Goodbey HDU。  </p>
<p>各奔东西的我们。<br>赌神回了东阳，混进了农行。<br>宗文放弃了读研，交了女朋友留在杭州写代码。<br>蒲少，还没来不得及问你志在何方。<br>富帅已经回来，最后一次见他，是在寝室打游戏。<br>Fight吧，少年们，用力活着用力爱哪怕肝脑涂地。      </p>
<p>还有。<br>敬爱青云书记，小胡子同学。<br>戴逗，涛哥，小董三人组。<br>耀卓，逗逗，鲜花。勇勇，奕廷。<br>离开计算机专业后的向宇，是否已经实现了你的梦想。<br>再见了，少年们，说了再见还会再见的吧。    </p>
<p><img src="/2017/06/14/Hello-World-Goodby-HDU/008.png" alt="&quot;都知欢聚最难得，难奈别离多&quot;"></p>
<p>那个少年。  </p>
<p>许多年前，有一双清澈的双眼。<br>想看遍这世界，去最遥远的远方。<br>感觉有双翅膀，能飞越高山和海洋。<br>爱上一个人，就不怕付出自己一生。<br>相信爱会永恒，相信每个陌生人。  </p>
<p>当我和世界初相见，当我曾经是少年。  </p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26508186&auto=1&height=66"></iframe>
]]></content>
      
        <categories>
            
            <category> 所有的酒 都不如你 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> School </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
